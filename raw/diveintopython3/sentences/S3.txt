You are here: Home ‣ Dive Into Python 3 ‣
当前位置: 首页 ‣ 深入 Python 3 ‣

Difficulty level: ♦♦♢♢♢
难度级别: ♦♦♢♢♢

Native Datatypes
内置数据类型

❝ Wonder is the foundation of all philosophy, inquiry its progress, ignorance its end.
❝ Wonder is the foundation of all philosophy, inquiry its progress, ignorance its end. ❞ — Michel de Montaigne

Diving In
深入

Datatypes.
让我们暂时将 第一份 Python 程序 抛在脑后，来聊一聊数据类型

Set aside your first Python program for just a minute, and let’s talk about datatypes.
在 Python 中， 每个值都有一种数据类型，但您并不需要声明变量的数据类型

In Python, every value has a datatype, but you don’t need to declare the datatype of variables.
那该方式是如何运作的呢

How does that work?
Python 根据每个变量的初始赋值情况分析其类型，并在内部对其进行跟踪

Python has many native datatypes.
Python 有多种内置数据类型

Here are the important ones:
以下是比较重要的一些：

Booleans are either True or False.
Booleans［布尔型］ 或为 True［真］ 或为 False［假］

Numbers can be integers (1 and 2), floats (1.1 and 1.2), fractions (1/2 and 2/3), or even complex numbers.
Numbers［数值型］ 可以是 Integers［整数］（1 和 2）、Floats［浮点数］（1.1 和 1.2）、Fractions［分数］（1/2 和 2/3）

Strings are sequences of Unicode characters, e.g.
Strings［字符串型］ 是 Unicode 字符序列，例如： 一份 HTML 文档

Bytes and byte arrays, e.g.
Bytes［字节］ 和 Byte Arrays［字节数组］， 例如: 一份 JPEG 图像文件

Lists are ordered sequences of values.
Lists［列表］ 是值的有序序列

Tuples are ordered, immutable sequences of values.
Tuples［元组］ 是有序而不可变的值序列

Sets are unordered bags of values.
Sets［集合］ 是装满无序值的包裹

Dictionaries are unordered bags of key-value pairs.
Dictionaries［字典］ 是键值对的无序包裹

Of course, there are more types than these.
当然，还有更多的类型

Everything is an object in Python, so there are types like module, function, class, method, file, and even compiled code.
在 Python 中一切均为对象，因此存在像 module［模块］、 function［函数］、 class［类］、 method［方法］、 file［文件］ 甚至 compiled code［已编译代码］ 这样的类型

You’ve already seen some of these: modules have names, functions have docstrings, &c.
您已经见过这样一些例子：模块的 name、 函数的 docstrings 等等

You’ll learn about classes in Classes & Iterators, and about files in Files.
将学到的包括 《类 与 迭代器》 中的 Classes［类］，以及 《文件》 中的 Files［文件］

Strings and bytes are important enough — and complicated enough — that they get their own chapter.
Strings［字符串］和 Bytes［字节串］比较重要，也相对复杂，足以开辟独立章节予以讲述

Let’s look at the others first.
让我们先看看其它类型

Booleans
布尔类型

Booleans are either true or false.
布尔类型或为真或为假

Python has two constants, cleverly named True and False, which can be used to assign boolean values directly.
Python 有两个被巧妙地命名为 True 和 False 的常量，可用于对布尔类型的直接赋值

Expressions can also evaluate to a boolean value.
表达式也可以计算为布尔类型的值

In certain places (like if statements), Python expects an expression to evaluate to a boolean value.
在某些地方（如 if 语句），Python 所预期的就是一个可计算出布尔类型值的表达式

These places are called boolean contexts.
这些地方称为 布尔类型上下文环境

You can use virtually any expression in a boolean context, and Python will try to determine its truth value.
事实上，可在布尔类型上下文环境中使用任何表达式，而 Python 将试图判断其真值

Different datatypes have different rules about which values are true or false in a boolean context.
在布尔类型上下文环境中，不同的数据类型对于何值为真、何值为假有着不同的规则

(This will make more sense once you see some concrete examples later in this chapter.)
（看过本章稍后的实例后，这一点将更好理解

For example, take this snippet from humansize.py:
例如，看看 humansize.py 中的这个片段：

size is an integer, 0 is an integer, and < is a numerical operator.
size 是整数， 0 是整数，而 < 是数字运算符

The result of the expression size < 0 is always a boolean.
size < 0 表达式的结果始终是布尔值

You can test this yourself in the Python interactive shell:
可在 Python 交互式 shell 中自行测试下结果：

Due to some legacy issues left over from Python 2, booleans can be treated as numbers.
由于 Python 2 的一些遗留问题，布尔值可以当做数值对待

True is 1;
True 为 1

False is 0.
False 为 0 

Ew, ew, ew!
喔，喔，喔

Don’t do that.
别那么干

Forget I even mentioned it.
忘掉我刚才说的

Numbers
数值类型

Numbers are awesome.
数值类型是可畏的

There are so many to choose from.
有太多类型可选了

Python supports both integers and floating point numbers.
Python 同时支持 Integer［整型］ 和 Floating Point［浮点型］ 数值

There’s no type declaration to distinguish them;
无任何类型声明可用于区分

Python tells them apart by the presence or absence of a decimal point.
Python 通过是否有 小数 点来分辨它们

You can use the type() function to check the type of any value or variable.
可以使用 type() 函数来检测任何值或变量的类型

As you might expect, 1 is an int.
正如所料，1 为 int 类型

Similarly, you can use the isinstance() function to check whether a value or variable is of a given type.
同样，还可使用 isinstance() 函数判断某个值或变量是否为给定某个类型

Adding an int to an int yields an int.
将一个 int 与一个 int 相加将得到一个 int 

Adding an int to a float yields a float.
将一个 int 与一个 float 相加将得到一个 float 

Python coerces the int into a float to perform the addition, then returns a float as the result.
Python 把 int 强制转换为 float 以进行加法运算

Coercing Integers To Floats And Vice-Versa
将整数强制转换为浮点数及反向转换

As you just saw, some operators (like addition) will coerce integers to floating point numbers as needed.
正如刚才所看到的，一些运算符（如：加法）会根据需把整数强制转换为浮点数

You can also coerce them by yourself.
也可自行对其进行强制转换

You can explicitly coerce an int to a float by calling the float() function.
通过调用float() 函数，可以显示地将 int 强制转换为 float

Unsurprisingly, you can also coerce a float to an int by calling int().
毫不出奇，也可以通过调用 int() 将 float 强制转换为 int 

The int() function will truncate, not round.
int() 将进行取整，而不是四舍五入

The int() function truncates negative numbers towards 0.
对于负数，int() 函数朝着 0 的方法进行取整

It’s a true truncate function, not a floor function.
它是个真正的取整（截断）函数，而不是 floor［地板］函数

Floating point numbers are accurate to 15 decimal places.
浮点数精确到小数点后 15 位

Integers can be arbitrarily large.
整数可以任意大

☞Python 2 had separate types for int and long.
☞Python 2 对于int［整型］ 和 long［长整型］ 采用不同的数据类型

The int datatype was limited by sys.maxint, which varied by platform but was usually 232-1.
int 数据类型受到 sys.maxint 的限制，因平台该限制也会有所不同，但通常是 232-1 

Python 3 has just one integer type, which behaves mostly like the old long type from Python 2.
Python 3 只有一种整数类型，其行为方式很有点像 Python 2 的旧 long［长整数］ 类型

See PEP 237 for details.
参阅 PEP 237 了解更多细节

Common Numerical Operations
常见数值运算

You can do all kinds of things with numbers.
对数值可进行各种类型的运算

The / operator performs floating point division.
/ 运算符执行浮点除法

It returns a float even if both the numerator and denominator are ints.
即便分子和分母都是 int，它也返回一个 float 浮点数

The // operator performs a quirky kind of integer division.
// 运算符执行古怪的整数除法

When the result is positive, you can think of it as truncating (not rounding) to 0 decimal places, but be careful with that.
如果结果为正数，可将其视为朝向小数位取整（不是四舍五入），但是要小心这一点

When integer-dividing negative numbers, the // operator rounds “up” to the nearest integer.
当整数除以负数， // 运算符将结果朝着最近的整数“向上”四舍五入

Mathematically speaking, it’s rounding “down” since −6 is less than −5, but it could trip you up if you were expecting it to truncate to −5.
从数学角度来说，由于 −6 比 −5 要小，它是“向下”四舍五入，如果期望将结果取整为 −5，它将会误导你

The // operator doesn’t always return an integer.
// 运算符并非总是返回整数结果

If either the numerator or denominator is a float, it will still round to the nearest integer, but the actual return value will be a float.
如果分子或者分母是 float，它仍将朝着最近的整数进行四舍五入，但实际返回的值将会是 float 类型

The ** operator means “raised to the power of.” 112 is 121.
** 运算符的意思是“计算幂”，112 结果为 121 

The % operator gives the remainder after performing integer division.
% 运算符给出了进行整除之后的余数

 divided by 2 is 5 with a remainder of 1, so the result here is 1.
11 除以 2 结果为 5 以及余数 1，因此此处的结果为 1

☞In Python 2, the / operator usually meant integer division, but you could make it behave like floating point division by including a special directive in your code.
☞在 Python 2 中，运算符 / 通常表示整数除法，但是可以通过在代码中加入特殊指令，使其看起来像浮点除法

In Python 3, the / operator always means floating point division.
在 Python 3 中，/ 运算符总是表示浮点除法

See PEP 238 for details.
参阅 PEP 238 了解更多细节

Fractions
分数

Python isn’t limited to integers and floating point numbers.
Python 并不仅仅局限于整数和浮点数类型

It can also do all the fancy math you learned in high school and promptly forgot about.
它可以完成你在高中阶段学过、但几乎已经全部忘光的所有古怪数学运算

To start using fractions, import the fractions module.
为启用 fractions 模块，必先引入 fractions 模块

To define a fraction, create a Fraction object and pass in the numerator and denominator.
为定义一个分数，创建一个 Fraction 对象并传入分子和分母

You can perform all the usual mathematical operations with fractions.
可对分数进行所有的常规数学计算

Operations return a new Fraction object.
运算返回一个新的 Fraction 对象

 * (1/3) = (2/3)
2 * (1/3) = (2/3)

The Fraction object will automatically reduce fractions.
Fraction 对象将会自动进行约分

(6/4) = (3/2)
(6/4) = (3/2)

Python has the good sense not to create a fraction with a zero denominator.
在杜绝创建以零为分母的分数方面，Python 有着良好的敏感性

Trigonometry
三角函数

You can also do basic trigonometry in Python.
还可在 Python 中进行基本的三角函数运算

The math module has a constant for π, the ratio of a circle’s circumference to its diameter.
math 模块中有一个代表 π 的常量，表示圆的周长与直径之比率（圆周率）

The math module has all the basic trigonometric functions, including sin(), cos(), tan(), and variants like asin().
math 模块包括了所有的基本三角函数，包括：sin()、 cos()、tan() 及像 asin() 这样的变体函数

Note, however, that Python does not have infinite precision.
然而要注意的是 Python 并不支持无限精度

tan(π / 4) should return 1.0, not 0.99999999999999989.
tan(π / 4) 将返回 1.0，而不是 0.99999999999999989

Numbers In A Boolean Context
布尔上下文环境中的数值

You can use numbers in a boolean context, such as an if statement.
可以在 if 这样的 布尔类型上下文环境中 使用数值

Zero values are false, and non-zero values are true.
零值是 false［假］，非零值是 true［真］

Did you know you can define your own functions in the Python interactive shell?
您知道可以在 Python 交互式 Shell 中定义自己的函数吗

Just press ENTER at the end of each line, and ENTER on a blank line to finish.
只需在每行的结尾按 回车键 ，然后在某一空行按 回车键 结束

In a boolean context, non-zero integers are true;
在布尔类型上下文环境中，非零整数为真

 is false.
零为假

Non-zero floating point numbers are true;
非零浮点数为真

.0 is false.
 0.0 为假

Be careful with this one!
请千万小心这一点

If there’s the slightest rounding error (not impossible, as you saw in the previous section) then Python will be testing 0.0000000000001 instead of 0 and will return True.
如果有轻微的四舍五入偏差（正如在前面小节中看到的那样，这并非不可能的事情），那么 Python 将测试 0.0000000000001 而不是 0 ，并将返回一个 True 值

Fractions can also be used in a boolean context.
分数也可在布尔类型上下文环境中使用

Fraction(0, n) is false for all values of n.
无论 n 为何值，Fraction(0, n) 为假

All other fractions are true.
所有其它分数为真

Lists
列表

Lists are Python’s workhorse datatype.
列表是 Python 的主力数据类型

When I say “list,” you might be thinking “array whose size I have to declare in advance, that can only contain items of the same type, &c.” Don’t think that.
当提到 “列表 ”时，您脑海中可能会闪现“必须进一步声明大小的数组，只能包含同一类对象“ 等想法

Lists are much cooler than that.
千万别这么想

☞A list in Python is like an array in Perl 5.
☞ Python 中的列表类似 Perl 5 中的数组

In Perl 5, variables that store arrays always start with the @ character;
在 Perl 5 中，存储数组的变量总是以字符 @ 开头

in Python, variables can be named anything, and Python keeps track of the datatype internally.
在 Python 中，变量可随意命名，Python 仅在内部对数据类型进行跟踪

☞A list in Python is much more than an array in Java (although it can be used as one if that’s really all you want out of life).
☞ Python 中的列表更像 Java 中的数组（尽管可以把列表当做生命中所需要的一切来使用)

A better analogy would be to the ArrayList class, which can hold arbitrary objects and can expand dynamically as new items are added.
一个更好的比喻可能是 ArrayList 类，该类可以容纳任何对象，并可在添加新元素时进行动态拓展

Creating A List
创建列表

Creating a list is easy: use square brackets to wrap a comma-separated list of values.
列表创建非常轻松：使用中括号包裹一系列以逗号分割的值即可

First, you define a list of five items.
首先，创建一个包含 5 个元素的列表

Note that they retain their original order.
要注意的是它们保持了最初的顺序

This is not an accident.
这并不是偶然的

A list is an ordered set of items.
列表是元素的有序集合

A list can be used like a zero-based array.
列表可当做以零为基点的数组使用

The first item of any non-empty list is always a_list[0].
非空列表的首个元素始终是 a_list[0] 

The last item of this five-item list is a_list[4], because lists are always zero-based.
该 5 元素列表的最后一个元素是 a_list[4]，因为列表（索引）总是以零为基点的

A negative index accesses items from the end of the list counting backwards.
使用负索引值可从列表的尾部向前计数访问元素

The last item of any non-empty list is always a_list[-1].
任何非空列表的最后一个元素总是 a_list[-1] 

If the negative index is confusing to you, think of it this way: a_list[-n] == a_list[len(a_list) - n].
如果负数令你混淆，可将其视为如下方式： a_list[-n] == a_list[len(a_list) - n] 

So in this list, a_list[-3] == a_list[5 - 3] == a_list[2].
因此在此列表中， a_list[-3] == a_list[5 - 3] == a_list[2]

Slicing A List
列表切片

Once you’ve defined a list, you can get any part of it as a new list.
定义列表后，可从其中获取任何部分作为新列表

This is called slicing the list.
该技术称为对列表进行 切片 

You can get a part of a list, called a “slice”, by specifying two indices.
通过指定两个索引值，可以从列表中获取称作“切片”的某个部分

The return value is a new list containing all the items of the list, in order, starting with the first slice index (in this case a_list[1]), up to but not including the second slice index (in this case a_list[3]).
返回值是一个新列表，它包含列表(??切片)中所有元素，按顺序从第一个切片索引开始（本例中为 a_list[1]），截止但不包含第二个切片索引（本例中的 a_list[3]）

Slicing works if one or both of the slice indices is negative.
如果切片索引之一或两者均为负数，切片操作仍可进行

If it helps, you can think of it this way: reading the list from left to right, the first slice index specifies the first item you want, and the second slice index specifies the first item you don’t want.
如果有帮助的话，您可以这么思考：自左向右读取列表，第一个切片索引指明了想要的第一个元素，第二个切片索引指明了第一个不想要的元素

The return value is everything in between.
返回值是两者之间的任何值

Lists are zero-based, so a_list[0:3] returns the first three items of the list, starting at a_list[0], up to but not including a_list[3].
列表是以零为起点的，因此 a_list[0:3] 返回列表的头三个元素，从 a_list[0] 开始，截止到但不包括 a_list[3] 

If the left slice index is 0, you can leave it out, and 0 is implied.
如果左切片索引为零，可以将其留空而将零隐去

So a_list[:3] is the same as a_list[0:3], because the starting 0 is implied.
因此 a_list[:3] 与 a_list[0:3] 是完全相同的，因为起点 0 被隐去了

Similarly, if the right slice index is the length of the list, you can leave it out.
同样，如果右切片索引为列表的长度，也可以将其留空

So a_list[3:] is the same as a_list[3:5], because this list has five items.
因此 a_list[3:] 与 a_list[3:5] 是完全相同的，因为该列表有五个元素

There is a pleasing symmetry here.
此处有个好玩的对称现象

In this five-item list, a_list[:3] returns the first 3 items, and a_list[3:] returns the last two items.
在这个五元素列表中， a_list[:3] 返回头三个元素，而 a_list[3:] 返回最后两个元素

In fact, a_list[:n] will always return the first n items, and a_list[n:] will return the rest, regardless of the length of the list.
事实上，无论列表的长度是多少, a_list[:n] 将返回头 n 个元素，而 a_list[n:] 返回其余部分

If both slice indices are left out, all items of the list are included.
如果两个切片索引都留空，那么将包括列表所有的元素

But this is not the same as the original a_list variable.
但该返回值与最初的 a_list 变量并不一样

It is a new list that happens to have all the same items.
它是一个新列表，只不过恰好拥有完全相同的元素而已

a_list[:] is shorthand for making a complete copy of a list.
a_list[:] 是对列表进行复制的一条捷径

Adding Items To A List
向列表中新增项

There are four ways to add items to a list.
有四种方法可用于向列表中增加元素

The + operator concatenates lists to create a new list.
+ 运算符连接列表以创建一个新列表

A list can contain any number of items;
列表可包含任何数量的元素

there is no size limit (other than available memory).
没有大小限制（除了可用内存的限制）

However, if memory is a concern, you should be aware that list concatenation creates a second list in memory.
然而，如果内存是个问题，那就必须知道在进行连接操作时，将在内存中创建第二个列表

In this case, that new list is immediately assigned to the existing variable a_list.
在该情况下，新列表将会立即被赋值给已有变量 a_list 

So this line of code is really a two-step process — concatenation then assignment — which can (temporarily) consume a lot of memory when you’re dealing with large lists.
因此，实际上该行代码包含两个步骤 — 连接然后赋值 — 当处理大型列表时，该操作可能（暂时）消耗大量内存

A list can contain items of any datatype, and the items in a single list don’t all need to be the same type.
列表可包含任何数据类型的元素，单个列表中的元素无须全为同一类型

Here we have a list containing a string, a floating point number, and an integer.
下面的列表中包含一个字符串、一个浮点数和一个整数

The append() method adds a single item to the end of the list.
append() 方法向列表的尾部添加一个新的元素

(Now we have four different datatypes in the list!)
（现在列表中有 四种 不同数据类型

Lists are implemented as classes.
列表是以类的形式实现的

“Creating” a list is really instantiating a class.
“创建”列表实际上是将一个类实例化

As such, a list has methods that operate on it.
因此，列表有多种方法可以操作

The extend() method takes one argument, a list, and appends each of the items of the argument to the original list.
extend() 方法只接受一个列表作为参数，并将该参数的每个元素都添加到原有的列表中

The insert() method inserts a single item into a list.
insert() 方法将单个元素插入到列表中

The first argument is the index of the first item in the list that will get bumped out of position.
第一个参数是列表中将被顶离原位的第一个元素的位置索引

List items do not need to be unique;
列表中的元素并不一定要是唯一的

for example, there are now two separate items with the value 'Ω': the first item, a_list[0], and the last item, a_list[6].
比如说：现有两个各自独立的元素，其值均为 'Ω':，第一个元素 a_list[0] 以及最后一个元素 a_list[6] 

☞a_list.insert(0, value) is like the unshift() function in Perl.
☞a_list.insert(0, value) 就像是 Perl 中的 unshift() 函数

It adds an item to the beginning of the list, and all the other items have their positional index bumped up to make room.
它将一个元素添加到列表的头部，所有其它的元素都被顶理原先的位置以腾出空间

Let’s look closer at the difference between append() and extend().
让我们进一步看看 append() 和 extend() 的区别

The extend() method takes a single argument, which is always a list, and adds each of the items of that list to a_list.
extend() 方法只接受一个参数，而该参数总是一个列表，并将列表 a_list 中所有的元素都添加到该列表中

If you start with a list of three items and extend it with a list of another three items, you end up with a list of six items.
如果开始有个 3 元素列表，然后将它与另一个 3 元素列表进行 extend 操作，结果是将获得一个 6 元素列表

On the other hand, the append() method takes a single argument, which can be any datatype.
另一方面， append() 方法只接受一个参数，但可以是任何数据类型

Here, you’re calling the append() method with a list of three items.
在此，对一个 3 元素列表调用 append() 方法

If you start with a list of six items and append a list onto it, you end up with...
如果开始的时候有个 6 元素列表，然后将一个列表 append［添加］上去，结果就会……得到一个 7 元素列表

a list of seven items.
为什么是 7 个

Why seven?
因为最后一个元素（刚刚 append［添加］ 的元素） 本身是个列表 

Because the last item (which you just appended) is itself a list.
列表可包含任何类型的数据，包括其它列表

Lists can contain any type of data, including other lists.
这可能是你所需要的结果，也许不是

That may be what you want, or it may not.
但如果这就是你想要的，那这就是你所得到的

Searching For Values In A List
在列表中检索值

As you might expect, the count() method returns the number of occurrences of a specific value in a list.
如你所期望， count() 方法返回了列表中某个特定值出现的次数

If all you want to know is whether a value is in the list or not, the in operator is slightly faster than using the count() method.
如果你想知道的是某个值是否出现在列表中， in 运算符将会比使用 count() 方法要略快一些

The in operator always returns True or False;
in 运算符总是返回 True 或 False

it will not tell you how many times the value appears in the list.
它不会告诉你该值出现在什么位置

Neither the in operator nor the count() method will tell you where in the list a value appears.
如果想知道某个值在列表中的精确位置，可调用 index() 方法

If you need to know where in the list a value is, call the index() method.
尽管可以通过第二个参数（以 0 为基点的）索引值来指定起点，通过第三个参数（以 0 基点的）索引来指定搜索终点，但缺省情况下它将搜索整个列表，

The index() method finds the first occurrence of a value in the list.
index() 方法将查找某值在列表中的第一次出现

In this case, 'new' occurs twice in the list, in a_list[2] and a_list[4], but the index() method will return only the index of the first occurrence.
在该情况下，'new' 在列表中出现了两次，分别为 a_list[2] 和 a_list[4]，但 index() 方法将只返回第一次出现的位置索引值

As you might not expect, if the value is not found in the list, the index() method will raise an exception.
可能 出乎 您的预期，如果在列表中没有找到该值，index() 方法将会引发一个例外

Wait, what?
等等，什么

That’s right: the index() method raises an exception if it doesn’t find the value in the list.
是这样的：如果没有在列表中找到该值， index() 方法将会引发一个例外

This is notably different from most languages, which will return some invalid index (like -1).
这是 Python 语言最显著不同之处，其它多数语言将会返回一些无效的索引值（像是 -1）

While this may seem annoying at first, I think you will come to appreciate it.
当然，一开始这一点看起来比较讨厌，但我想您会逐渐欣赏它

It means your program will crash at the source of the problem instead of failing strangely and silently later.
这意味着您的程序将会在问题的源头处崩溃，而不是之后奇怪地、默默地崩溃

Remember, -1 is a valid list index.
请记住， -1 是合法的列表索引值

If the index() method returned -1, that could lead to some not-so-fun debugging sessions!
如果 index() 方法返回 -1，可能会导致调整过程变得不那么有趣

Removing Items From A List
从列表中删除元素

Lists can expand and contract automatically.
列表可以自动拓展或者收缩

You’ve seen the expansion part.
您已经看到了拓展部分

There are several different ways to remove items from a list as well.
也有几种方法可从列表中删除元素

You can use the del statement to delete a specific item from a list.
可使用 del 语句从列表中删除某个特定元素

Accessing index 1 after deleting index 1 does not result in an error.
删除索引 1 之后再访问索引 1 将 不会 导致错误

All items after the deleted item shift their positional index to “fill the gap” created by deleting the item.
被删除元素之后的所有元素将移动它们的位置以“填补”被删除元素所产生的“缝隙”

Don’t know the positional index?
不知道位置索引

Not a problem;
这不成问题，您可以通过值而不是索引删除元素

You can also remove an item from a list with the remove() method.
还可以通过 remove() 方法从列表中删除某个元素

The remove() method takes a value and removes the first occurrence of that value from the list.
remove() 方法接受一个 value 参数，并删除列表中该值的第一次出现

Again, all items after the deleted item will have their positional indices bumped down to “fill the gap.” Lists never have gaps.
同样，被删除元素之后的所有元素将会将索引位置下移，以“填补缝隙”

You can call the remove() method as often as you like, but it will raise an exception if you try to remove a value that isn’t in the list.
您可以尽情地调用 remove() 方法，但如果试图删除列表中不存在的元素，它将引发一个例外

Removing Items From A List: Bonus Round
Removing Items From A List: Bonus Round

Another interesting list method is pop().
另一有趣的列表方法是 pop() 

The pop() method is yet another way to remove items from a list, but with a twist.
pop() 方法是从列表删除元素的另一方法，但有点变化

When called without arguments, the pop() list method removes the last item in the list and returns the value it removed.
如果不带参数调用， pop() 列表方法将删除列表中最后的元素，并返回所删除的值

You can pop arbitrary items from a list.
可以从列表中 pop［弹出］任何元素

Just pass a positional index to the pop() method.
只需传给 pop() 方法一个位置索引值

It will remove that item, shift all the items after it to “fill the gap,” and return the value it removed.
它将删除该元素，将其后所有元素移位以“填补缝隙”,然后返回它删除的值

Calling pop() on an empty list raises an exception.
对空列表调用 pop() 将会引发一个例外

☞Calling the pop() list method without an argument is like the pop() function in Perl.
☞不带参数调用的 pop() 列表方法就像 Perl 中的 pop() 函数

It removes the last item from the list and returns the value of the removed item.
它从列表中删除最后一个元素并返回所删除元素的值

Perl has another function, shift(), which removes the first item and returns its value;
Perl 还有另一个函数 shift()，可用于删除第一个元素并返回其值

in Python, this is equivalent to a_list.pop(0).
在 Python 中，该函数相当于 a_list.pop(0) 

Lists In A Boolean Context
布尔上下文环境中的列表

You can also use a list in a boolean context, such as an if statement.
可以在 if 这样的 布尔类型上下文环境中 使用列表

In a boolean context, an empty list is false.
在布尔类型上下文环境中，空列表为假值

Any list with at least one item is true.
任何至少包含一个上元素的列表为真值

Any list with at least one item is true.
任何至少包含一个上元素的列表为真值

The value of the items is irrelevant.
元素的值无关紧要

Tuples
元组

A tuple is an immutable list.
元素 是不可变的列表

A tuple can not be changed in any way once it is created.
一旦创建之后，用任何方法都不可以修改元素

A tuple is defined in the same way as a list, except that the whole set of elements is enclosed in parentheses instead of square brackets.
元组的定义方式和列表相同，除了整个元素的集合都用圆括号，而不是方括号闭合

The elements of a tuple have a defined order, just like a list.
和列表一样，元组的元素都有确定的顺序

Tuple indices are zero-based, just like a list, so the first element of a non-empty tuple is always a_tuple[0].
元组的索引也是以零为基点的，和列表一样，因此非空元组的第一个元素总是 a_tuple[0] 

Negative indices count from the end of the tuple, just like a list.
负的索引从元组的尾部开始计数，这和列表也是一样的

Slicing works too, just like a list.
和列表一样，元组也可以进行切片操作

When you slice a list, you get a new list;
对列表切片可以得到新的列表

when you slice a tuple, you get a new tuple.
对元组切片可以得到新的元组

The major difference between tuples and lists is that tuples can not be changed.
元组和列表的主要区别是元组不能进行修改

In technical terms, tuples are immutable.
用技术术语来说，元组是 不可变更 的

In practical terms, they have no methods that would allow you to change them.
从实践的角度来说，没有可用于修改元组的方法

Lists have methods like append(), extend(), insert(), remove(), and pop().
列表有像 append()、 extend()、 insert()、remove() 和 pop() 这样的方法

Tuples have none of these methods.
这些方法，元组都没有

You can slice a tuple (because that creates a new tuple), and you can check whether a tuple contains a particular value (because that doesn’t change the tuple), and… that’s about it.
可以对元组进行切片操作（因为该方法创建一个新的元组），可以检查元组是否包含了特定的值（因为该操作不修改元组），还可以……就那么多了

You can’t add elements to a tuple.
无法向元组添加元素

Tuples have no append() or extend() method.
元组没有 append() 或 extend() 方法

You can’t remove elements from a tuple.
不能从元组中删除元素

Tuples have no remove() or pop() method.
元组没有 remove() 或 pop() 方法

You can find elements in a tuple, since this doesn’t change the tuple.
可以 在元组中查找元素，由于该操作不改变元组

You can also use the in operator to check if an element exists in the tuple.
还可以使用 in 运算符检查某元素是否存在于元组中

So what are tuples good for?
那么元组有什么好处呢

Tuples are faster than lists.
元组的速度比列表更快

If you’re defining a constant set of values and all you’re ever going to do with it is iterate through it, use a tuple instead of a list.
如果定义了一系列常量值，而所需做的仅是对它进行遍历，那么请使用元组替代列表

It makes your code safer if you “write-protect” data that doesn’t need to be changed.
对不需要改变的数据进行“写保护”将使得代码更加安全

Using a tuple instead of a list is like having an implied assert statement that shows this data is constant, and that special thought (and a specific function) is required to override that.
使用元组替代列表就像是有一条隐含的 assert 语句显示该数据是常量，特别的想法（及特别的功能）必须重写

Some tuples can be used as dictionary keys (specifically, tuples that contain immutable values like strings, numbers, and other tuples).
一些元组可用作字典键（特别是包含字符串、数值和其它元组这样的不可变数据的元组）

Lists can never be used as dictionary keys, because lists are not immutable.
列表永远不能当做字典键使用，因为列表不是不可变的

☞Tuples can be converted into lists, and vice-versa.
☞元组可转换成列表，反之亦然

The built-in tuple() function takes a list and returns a tuple with the same elements, and the list() function takes a tuple and returns a list.
内建的 tuple() 函数接受一个列表参数，并返回一个包含同样元素的元组，而 list() 函数接受一个元组参数并返回一个列表

In effect, tuple() freezes a list, and list() thaws a tuple.
从效果上看， tuple() 冻结列表，而 list() 融化元组

Tuples In A Boolean Context
布尔上下文环境中的元组

You can use tuples in a boolean context, such as an if statement.
可以在 if 这样的 布尔类型上下文环境中 使用元组

In a boolean context, an empty tuple is false.
在布尔类型上下文环境中，空元组为假值

Any tuple with at least one item is true.
任何至少包含一个上元素的元组为真值

Any tuple with at least one item is true.
任何至少包含一个上元素的元组为真值

The value of the items is irrelevant.
元素的值无关紧要

But what’s that comma doing there?
不过此处的逗号起什么作用呢

To create a tuple of one item, you need a comma after the value.
为创建单元素元组，需要在值之后加上一个逗号

Without the comma, Python just assumes you have an extra pair of parentheses, which is harmless, but it doesn’t create a tuple.
没有逗号，Python 会假定这只是一对额外的圆括号，虽然没有害处，但并不创建元组

Assigning Multiple Values At Once
同时赋多个值

Here’s a cool programming shortcut: in Python, you can use a tuple to assign multiple values at once.
以下是一种很酷的编程捷径：在 Python 中，可使用元组来一次赋多值

v is a tuple of three elements, and (x, y, z) is a tuple of three variables.
v 是一个三元素的元组，而 (x, y, z) 是包含三个变量的元组

Assigning one to the other assigns each of the values of v to each of the variables, in order.
将其中一个赋值给另一个将会把 v 中的每个值按顺序赋值给每一个变量

This has all kinds of uses.
该特性有多种用途

Suppose you want to assign names to a range of values.
假设需要将某个名称指定某个特定范围的值

You can use the built-in range() function with multi-variable assignment to quickly assign consecutive values.
可以使用内建的 range() 函数进行多变量赋值以快速地进行连续变量赋值

The built-in range() function constructs a sequence of integers.
内建的 range() 函数构造了一个整数序列

(Technically, the range() function returns an iterator, not a list or a tuple, but you’ll learn about that distinction later.) MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, and SUNDAY are the variables you’re defining.
（从技术上来说， range() 函数返回的既不是列表也不是元组，而是一个 迭代器，但稍后您将学到它们的区别

(This example came from the calendar module, a fun little module that prints calendars, like the UNIX program cal.
） MONDAY、 TUESDAY、 WEDNESDAY、 THURSDAY、 FRIDAY、 SATURDAY 和 SUNDAY 是您所定义的变量

The calendar module defines integer constants for days of the week.)
（本例来自于 calendar 模块，该短小而有趣的模块打印日历，有点像 UNIX 程序 cal 

Now each variable has its value: MONDAY is 0, TUESDAY is 1, and so forth.
现在，每个变量都有其值了： MONDAY 为 0， TUESDAY 为 1，如此类推

You can also use multi-variable assignment to build functions that return multiple values, simply by returning a tuple of all the values.
还可以使用多变量赋值创建返回多值的函数，只需返回一个包含所有值的元组

The caller can treat it as a single tuple, or it can assign the values to individual variables.
调用者可将返回值视为一个简单的元组，或将其赋值给不同的变量

Many standard Python libraries do this, including the os module, which you'll learn about in the next chapter.
许多标准 Python 类库这么干，包括在下一章将学到的 os 模块

Sets
集合

A set is an unordered “bag” of unique values.
集合set 是装有独特值的无序“袋子”

A single set can contain values of any immutable datatype.
一个简单的集合可以包含任何数据类型的值

Once you have two sets, you can do standard set operations like union, intersection, and set difference.
如果有两个集合，则可以执行像联合、交集以及集合求差等标准集合运算

Creating A Set
创建集合

First things first.
重中之重

Creating a set is easy.
创建集合非常简单

To create a set with one value, put the value in curly brackets ({}).
要创建只包含一个值的集合，仅需将该值放置于花括号之间

Sets are actually implemented as classes, but don’t worry about that for now.
实际上，集合以 类 的形式实现，但目前还无须考虑这一点

To create a set with multiple values, separate the values with commas and wrap it all up with curly brackets.
要创建多值集合，请将值用逗号分开，并用花括号将所有值包裹起来

You can also create a set out of a list.
还可以 列表 为基础创建集合

To create a set from a list, use the set() function.
要从列表创建集合，可使用 set() 函数

(Pedants who know about how sets are implemented will point out that this is not really calling a function, but instantiating a class.
（懂得如何实现集合的学究可能指出这实际上并不是调用某个函数，而是对某个类进行实例化

I promise you will learn the difference later in this book.
我保证在本书稍后的地方将会学到其中的区别

For now, just know that set() acts like a function, and it returns a set.)
目前而言，仅需知道 set() 行为与函数类似，以及它返回一个集合

As I mentioned earlier, a single set can contain values of any datatype.
正如我之前提到的，简单的集合可以包括任何数据类型的值

And, as I mentioned earlier, sets are unordered.
而且，如我之前所提到的，集合是 无序的

This set does not remember the original order of the list that was used to create it.
该集合并不记得用于创建它的列表中元素的最初顺序

If you were to add items to this set, it would not remember the order in which you added them.
如果向集合中添加元素，它也不会记得添加的顺序

The original list is unchanged.
初始的列表并不会发生变化

Don’t have any values yet?
还没有任何值

Not a problem.
没有问题

You can create an empty set.
可以创建一个空的集合

To create an empty set, call set() with no arguments.
要创建空集合，可不带参数调用 set() 

The printed representation of an empty set looks a bit strange.
打印出来的空集合表现形式看起来有点儿怪

Were you expecting {}, perhaps?
也许，您期望看到一个 {} 吧 

That would denote an empty dictionary, not an empty set.
该符号表示一个空的字典，而不是一个空的集合

You’ll learn about dictionaries later in this chapter.
本章稍后您将学到关于字典的内容

Despite the strange printed representation, this is a set…
尽管打印出的形式奇怪，这 确实是 一个集合……

…and this set has no members.
…… 同时该集合没有任何成员

Due to historical quirks carried over from Python 2, you can not create an empty set with two curly brackets.
由于从 Python 2 沿袭而来历史的古怪规定，不能使用两个花括号来创建空集合

This actually creates an empty dictionary, not an empty set.
该操作实际创建一个空字典，而不是一个空集合

Modifying A Set
修改集合

There are two different ways to add values to an existing set: the add() method, and the update() method.
有两种方法可向现有集合中添加值： add() 方法和 update() 方法

The add() method takes a single argument, which can be any datatype, and adds the given value to the set.
add() 方法接受单个可以是任何数据类型的参数，并将该值添加到集合之中

This set now has 3 members.
该集合现在有三个成员了

Sets are bags of unique values.
集合是装 唯一值 的袋子

If you try to add a value that already exists in the set, it will do nothing.
如果试图添加一个集合中已有的值，将不会发生任何事情

It won’t raise an error;
将不会引发一个错误

it’s just a no-op.
只是一条空操作

This set still has 3 members.
该集合 仍然 只有三个成员

The update() method takes one argument, a set, and adds all its members to the original set.
update() 方法仅接受一个集合作为参数，并将其所有成员添加到初始列表中

It’s as if you called the add() method with each member of the set.
其行为方式就像是对参数集合中的每个成员调用 add() 方法

Duplicate values are ignored, since sets can not contain duplicates.
由于集合不能包含重复的值，因此重复的值将会被忽略

You can actually call the update() method with any number of arguments.
实际上，可以带任何数量的参数调用 update() 方法

When called with two sets, the update() method adds all the members of each set to the original set (dropping duplicates).
如果调用时传递了两个集合， update() 将会被每个集合中的每个成员添加到初始的集合当中（丢弃重复值）

The update() method can take objects of a number of different datatypes, including lists.
update() 方法还可接受一些其它数据类型的对象作为参数，包括列表

When called with a list, the update() method adds all the items of the list to the original set.
如果调用时传入列表，update() 将会把列表中所有的元素添加到初始集合中

Removing Items From A Set
从集合中删除元素

There are three ways to remove individual values from a set.
有三种方法可以用来从集合中删除某个值

The first two, discard() and remove(), have one subtle difference.
前两种，discard() 和 remove() 有细微的差异

The discard() method takes a single value as an argument and removes that value from the set.
discard() 接受一个单值作为参数，并从集合中删除该值

If you call the discard() method with a value that doesn’t exist in the set, it does nothing.
如果针对一个集合中不存在的值调用 discard() 方法，它不进行任何操作

No error;
不产生错误

it’s just a no-op.
只是一条空指令

The remove() method also takes a single value as an argument, and it also removes that value from the set.
remove() 方法也接受一个单值作为参数，也从集合中将其删除

Here’s the difference: if the value doesn’t exist in the set, the remove() method raises a KeyError exception.
区别在这里：如果该值不在集合中，remove() 方法引发一个 KeyError 例外

Like lists, sets have a pop() method.
就像列表，集合也有个 pop() 方法

The pop() method removes a single value from a set and returns the value.
pop() 方法从集合中删除某个值，并返回该值

However, since sets are unordered, there is no “last” value in a set, so there is no way to control which value gets removed.
然而，由于集合是无序的，并没有“最后一个”值的概念，因此无法控制删除的是哪一个值

It is completely arbitrary.
它基本上是随机的

The clear() method removes all values from a set, leaving you with an empty set.
clear() 方法删除集合中 所有 的值，留下一个空集合

This is equivalent to a_set = set(), which would create a new empty set and overwrite the previous value of the a_set variable.
它等价于 a_set = set()，该语句创建一个新的空集合，并用之覆盖 a_set 变量的之前的值

Attempting to pop a value from an empty set will raise a KeyError exception.
试图从空集合中弹出某值将会引发 KeyError 例外

Common Set Operations
常见集合操作

Python’s set type supports several common set operations.
Python 的 集合 类型支持几种常见的运算

To test whether a value is a member of a set, use the in operator.
要检测某值是否是集合的成员，可使用 in 运算符

This works the same as lists.
其工作原理和列表的一样

The union() method returns a new set containing all the elements that are in either set.
union() 方法返回一个新集合，其中装着 在两个 集合中出现的元素

The intersection() method returns a new set containing all the elements that are in both sets.
intersection() 方法返回一个新集合，其中装着 同时 在两个集合中出现的所有元素

The difference() method returns a new set containing all the elements that are in a_set but not b_set.
difference() 方法返回的新集合中，装着所有在 a_set 出现但未在 b_set 中的元素

The symmetric_difference() method returns a new set containing all the elements that are in exactly one of the sets.
symmetric_difference() 方法返回一个新集合，其中装着所有 只在其中一个 集合中出现的元素

Three of these methods are symmetric.
这三种方法是对称的

The symmetric difference of a_set from b_set looks different than the symmetric difference of b_set from a_set, but remember, sets are unordered.
a_set 与 b_set 的对称差分 看起来 和b_set 与 a_set 的对称差分不同，但请记住：集合是无序的

Any two sets that contain all the same values (with none left over) are considered equal.
任何两个包含所有同样值（无一遗漏）的集合可认为是相等的

And that’s exactly what happens here.
而这正是这里发生的事情

Don’t be fooled by the Python Shell’s printed representation of these sets.
不要被 Python Shell 对这些集合的输出形式所愚弄了

They contain the same values, so they are equal.
它们包含相同的值，因此是相等的

The union of two sets is also symmetric.
对两个集合的 Union［并集］操作也是对称的

The intersection of two sets is also symmetric.
对两个集合的 Intersection［交集］操作也是对称的

The difference of two sets is not symmetric.
对两个集合的 Difference［求差］操作不是对称的

That makes sense;
这是有意义的

it’s analogous to subtracting one number from another.
它类似于从一个数中减去另一个数

The order of the operands matters.
操作数的顺序会导致结果不同

Finally, there are a few questions you can ask of sets.
最后，有几个您可能会问到的问题

a_set is a subset of b_set — all the members of a_set are also members of b_set.
a_set 是 b_set 的 子集 — 所有 a_set 的成员均为 b_set 的成员

Asking the same question in reverse, b_set is a superset of a_set, because all the members of a_set are also members of b_set.
同样的问题反过来说， b_set 是 a_set 的 超集，因为 a_set 的所有成员均为 b_set 的成员

As soon as you add a value to a_set that is not in b_set, both tests return False.
一旦向 a_set 添加一个未在 b_set 中出现的值，两项测试均返回 False 

Sets In A Boolean Context
布尔上下文环境中的集合

You can use sets in a boolean context, such as an if statement.
可在 if 这样的 布尔类型上下文环境中 使用集合

In a boolean context, an empty set is false.
在布尔类型上下文环境中，空集合为假值

Any set with at least one item is true.
任何至少包含一个上元素的集合为真值

Any set with at least one item is true.
任何至少包含一个上元素的集合为真值

The value of the items is irrelevant.
元素的值无关紧要

Dictionaries
字典

A dictionary is an unordered set of key-value pairs.
字典 是键值对的无序集合

When you add a key to a dictionary, you must also add a value for that key.
向字典添加一个键的同时，必须为该键增添一个值

(You can always change the value later.) Python dictionaries are optimized for retrieving the value when you know the key, but not the other way around.
（之后可随时修改该值

☞A dictionary in Python is like a hash in Perl 5.
☞Python 中的字典与 Perl 5 中的 hash [散列]类似

In Perl 5, variables that store hashes always start with a % character.
在 Perl 5 中，散列存储的变量总是以一个 % 符开头

In Python, variables can be named anything, and Python keeps track of the datatype internally.
在 Python 中，变量可以随意命名，而 Python 内部跟踪其数据类型

Creating A Dictionary
创建字典

Creating a dictionary is easy.
创建字典非常简单

The syntax is similar to sets, but instead of values, you have key-value pairs.
其语法与 集合 的类似，但应当指定键值对而不是值

Once you have a dictionary, you can look up values by their key.
有了字典后，可以通过键来查找值

First, you create a new dictionary with two items and assign it to the variable a_dict.
首先，通过将两个字典项指定给 a_dict 变量创建了一个新字典

Each item is a key-value pair, and the whole set of items is enclosed in curly braces.
每个字典项都是一组键值对，整个字典项集合都被大括号包裹在内

'server' is a key, and its associated value, referenced by a_dict['server'], is 'db.diveintopython3.org'.
'server' 为键，通过 a_dict['server'] 引用的关联值为 'db.diveintopython3.org' 

'database' is a key, and its associated value, referenced by a_dict['database'], is 'mysql'.
'database' 为键，通过 a_dict['database'] 引用的关联值为 'mysql' 

You can get values by key, but you can’t get keys by value.
可以通过键获取值，但不能通过值获取键

So a_dict['server'] is 'db.diveintopython3.org', but a_dict['db.diveintopython3.org'] raises an exception, because 'db.diveintopython3.org' is not a key.
因此 a_dict['server'] 为 'db.diveintopython3.org'，而 a_dict['db.diveintopython3.org'] 会引发例外，因为 'db.diveintopython3.org' 并不是键

Modifying A Dictionary
修改字典

Dictionaries do not have any predefined size limit.
字典没有预定义的大小限制

You can add new key-value pairs to a dictionary at any time, or you can modify the value of an existing key.
可以随时向字典中添加新的键值对，或者修改现有键所关联的值

Continuing from the previous example:
继续前面的例子：

You can not have duplicate keys in a dictionary.
在字典中不允许有重复的键

Assigning a value to an existing key will wipe out the old value.
对现有的键赋值将会覆盖旧值

You can add new key-value pairs at any time.
可随时添加新的键值对

This syntax is identical to modifying existing values.
该语法与修改现有值相同

The new dictionary item (key 'user', value 'mark') appears to be in the middle.
新字典项（键为 'user'，值为 'mark'）出现在中间

In fact, it was just a coincidence that the items appeared to be in order in the first example;
事实上，在第一个例子中字典项按顺序出现是个巧合

it is just as much a coincidence that they appear to be out of order now.
现在它们不按顺序出现同样也是个巧合

Assigning a value to an existing dictionary key simply replaces the old value with the new one.
对既有字典键进行赋值只会用新值替代旧值

Will this change the value of the user key back to "mark"?
该操作会将 user 键的值改回 "mark" 吗

No!
不会

Look at the key closely — that’s a capital U in "User".
仔细看看该键——有个大写的 U 出现在 "User" 中

Dictionary keys are case-sensitive, so this statement is creating a new key-value pair, not overwriting an existing one.
字典键是区分大小写的，因此该语句创建了一组新的键值对，而不是覆盖既有的字典项

It may look similar to you, but as far as Python is concerned, it’s completely different.
对你来说它们可能是一样的，但对于 Python 而言它们是完全不同的

Mixed-Value Dictionaries
混合值字典

Dictionaries aren’t just for strings.
字典并非只能用于字符串

Dictionary values can be any datatype, including integers, booleans, arbitrary objects, or even other dictionaries.
字典的值可以是任何数据类型，包括整数、布尔值、任何对象，甚至是其它的字典

And within a single dictionary, the values don’t all need to be the same type;
而且就算在同一字典中，所有的值也无须是同一类型，您可根据需要混合匹配

you can mix and match as needed.
字典的键要严格得多，可以是字符串、整数和其它一些类型

Dictionary keys are more restricted, but they can be strings, integers, and a few other types.
在同一字典中也可混合、匹配使用不同数据类型的键

In fact, you’ve already seen a dictionary with non-string keys and values, in your first Python program.
实际上，您已经在 your first Python program 见过一个将非字符串用作键的字典了

Let's tear that apart in the interactive shell.
让我们在交互式 shell 中剖析一下：

Like lists and sets, the len() function gives you the number of keys in a dictionary.
类似 列表 和 集合 ，len() 函数将返回字典中键的数量

And like lists and sets, you can use the in operator to test whether a specific key is defined in a dictionary.
而且像列表和集合一样，可使用 in 运算符以测试某个特定的键是否在字典中

1000 is a key in the SUFFIXES dictionary;
1000 是 字典 SUFFIXES 的一个键

its value is a list of eight items (eight strings, to be precise).
其值为一个 8 元素列表（确切地说，是 8 个字符串）

Similarly, 1024 is a key in the SUFFIXES dictionary;
同样， 1024 是字典 SUFFIXES 的键

its value is also a list of eight items.
其值也是一个 8 元素列表

Since SUFFIXES[1000] is a list, you can address individual items in the list by their 0-based index.
由于 SUFFIXES[1000] 是列表，可以通过它们的 0 基点索引来获取列表中的单个元素

Dictionaries In A Boolean Context
布尔上下文环境中的字典

You can also use a dictionary in a boolean context, such as an if statement.
可以在 if 这样的 布尔类型上下文环境中 使用字典

In a boolean context, an empty dictionary is false.
在布尔类型上下文环境中，空字典为假值

Any dictionary with at least one key-value pair is true.
至少包含一个键值对的字典为真值

None
None

None is a special constant in Python.
None 是 Python 的一个特殊常量

It is a null value.
它是一个 空 值

None is not the same as False.
None 与 False 不同

None is not 0.
None 不是 0 

None is not an empty string.
None 不是空字符串

Comparing None to anything other than None will always return False.
将 None 与任何非 None 的东西进行比较将总是返回 False 

None is the only null value.
None 是唯一的空值

It has its own datatype (NoneType).
它有着自己的数据类型（NoneType）

You can assign None to any variable, but you can not create other NoneType objects.
可将 None 赋值给任何变量，但不能创建其它 NoneType 对象

All variables whose value is None are equal to each other.
所有值为 None 变量是相等的

None In A Boolean Context
布尔上下文环境中的 None

In a boolean context, None is false and not None is true.
在 布尔类型上下文环境中， None 为假值，而 not None 为真值

Further Reading
深入阅读

Boolean operations
布尔运算

Numeric types
数值类型

Sequence types
序列类型

Set types
集合类型

Mapping types
映射类型

fractions module
fractions［分数］ 模块

math module
math［数学］ 模块

PEP 237: Unifying Long Integers and Integers
PEP 237: 统一长整数和整数

PEP 238: Changing the Division Operator
PEP 238: 修改除法运算符

© 2001–11 Mark Pilgrim
© 2001–9 Mark Pilgrim

