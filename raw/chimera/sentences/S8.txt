Chapter 8. Classes and Objects
第八章：类与对象¶

The primary focus of this chapter is to present recipes to common programming patterns related to class definitions.
本章主要关注点的是和类定义有关的常见编程模型

Topics include making objects support common Python features, usage of special methods, encapsulation techniques, inheritance, memory management, and useful design patterns.
包括让对象支持常见的Python特性、特殊方法的使用、 类封装技术、继承、内存管理以及有用的设计模式

Changing the String Representation of Instances
8.1 改变对象的字符串显示¶

You want to change the output produced by printing or viewing instances to something more sensible.
你想改变对象实例的打印或显示输出，让它们更具可读性

To change the string representation of an instance, define the __str__() and __repr__() methods.
要改变一个实例的字符串表示，可重新定义它的 __str__() 和 __repr__() 方法

For example:
例如：

The __repr__() method returns the code representation of an instance, and is usually the text you would type to re-create the instance.
__repr__() 方法返回一个实例的代码表示形式，通常用来重新构造这个实例

The built-in repr() function returns this text, as does the interactive interpreter when inspecting values.
 内置的 repr() 函数返回这个字符串，跟我们使用交互式解释器显示的值是一样的

The __str__() method converts the instance to a string, and is the output produced by the str() and print() functions.
 __str__() 方法将实例转换为一个字符串，使用 str() 或 print() 函数会输出这个字符串

For example:
比如：

The implementation of this recipe also shows how different string representations may be used during formatting.
我们在这里还演示了在格式化的时候怎样使用不同的字符串表现形式

Specifically, the special !r formatting code indicates that the output of __repr__() should be used instead of __str__(), the default.
 特别来讲，!r 格式化代码指明输出使用 __repr__() 来代替默认的 __str__() 

You can try this experiment with the preceding class to see this:
 你可以用前面的类来试着测试下：

Defining __repr__() and __str__() is often good practice, as it can simplify debugging and instance output.
自定义 __repr__() 和 __str__() 通常是很好的习惯，因为它能简化调试和实例输出

For example, by merely printing or logging an instance, a programmer will be shown more useful information about the instance contents.
 例如，如果仅仅只是打印输出或日志输出某个实例，那么程序员会看到实例更加详细与有用的信息

It is standard practice for the output of __repr__() to produce text such that eval(repr(x)) == x.
__repr__() 生成的文本字符串标准做法是需要让 eval(repr(x)) == x 为真

If this is not possible or desired, then it is common to create a useful textual representation enclosed in < and > instead.
 如果实在不能这样子做，应该创建一个有用的文本表示，并使用 < 和 > 括起来

For example:
比如：

If no __str__() is defined, the output of __repr__() is used as a fallback.
如果 __str__() 没有被定义，那么就会使用 __repr__() 来代替输出

The use of format() in the solution might look a little funny, but the format code {0.x} specifies the x-attribute of argument 0.
上面的 format() 方法的使用看上去很有趣，格式化代码 {0.x} 对应的是第1个参数的x属性

So, in the following function, the 0 is actually the instance self:
 因此，在下面的函数中，0实际上指的就是 self 本身：

As an alternative to this implementation, you could also use the % operator and the following code:
作为这种实现的一个替代，你也可以使用 % 操作符，就像下面这样：

Customizing String Formatting
8.2 自定义字符串的格式化¶

You want an object to support customized formatting through the format() function and string method.
你想通过 format() 函数和字符串方法使得一个对象能支持自定义的格式化

To customize string formatting, define the __format__() method on a class.
为了自定义字符串的格式化，我们需要在类上面定义 __format__() 方法

For example:
例如：

Instances of the Date class now support formatting operations such as the following:
现在 Date 类的实例可以支持格式化操作了，如同下面这样：

The __format__() method provides a hook into Python’s string formatting functionality.
__format__() 方法给Python的字符串格式化功能提供了一个钩子

It’s important to emphasize that the interpretation of format codes is entirely up to the class itself.
 这里需要着重强调的是格式化代码的解析工作完全由类自己决定

Thus, the codes can be almost anything at all.
因此，格式化代码可以是任何值

For example, consider the following from the datetime module:
 例如，参考下面来自 datetime 模块中的代码：

There are some standard conventions for the formatting of the built-in types.
对于内置类型的格式化有一些标准的约定

See the documentation for the string module for a formal specification.
 可以参考 string模块文档 说明

Making Objects Support the Context-Management Protocol
8.3 让对象支持上下文管理协议¶

You want to make your objects support the context-management protocol (the with statement).
你想让你的对象支持上下文管理协议(with语句)

In order to make an object compatible with the with statement, you need to implement __enter__() and __exit__() methods.
为了让一个对象兼容 with 语句，你需要实现 __enter__() 和 __exit__() 方法

For example, consider the following class, which provides a network connection:
 例如，考虑如下的一个类，它能为我们创建一个网络连接：

The key feature of this class is that it represents a network connection, but it doesn’t actually do anything initially (e.g., it doesn’t establish a connection).
这个类的关键特点在于它表示了一个网络连接，但是初始化的时候并不会做任何事情(比如它并没有建立一个连接)

Instead, the connection is established and closed using the with statement (essentially on demand).
 连接的建立和关闭是使用 with 语句自动完成的，例如：

The main principle behind writing a context manager is that you’re writing code that’s meant to surround a block of statements as defined by the use of the with statement.
编写上下文管理器的主要原理是你的代码会放到 with 语句块中执行

When the with statement is first encountered, the __enter__() method is triggered.
 当出现 with 语句的时候，对象的 __enter__() 方法被触发， 它返回的值(如果有的话)会被赋值给 as 声明的变量

The return value of __enter__() (if any) is placed into the variable indicated with the as qualifier.
然后，with 语句块里面的代码开始执行

Afterward, the statements in the body of the with statement execute.
 最后，__exit__() 方法被触发进行清理工作

This control flow happens regardless of what happens in the body of the with statement, including if there are exceptions.
不管 with 代码块中发生什么，上面的控制流都会执行完，就算代码块中发生了异常也是一样的

In fact, the three arguments to the __exit__() method contain the exception type, value, and traceback for pending exceptions (if any).
 事实上，__exit__() 方法的第三个参数包含了异常类型、异常值和追溯信息(如果有的话)

The __exit__() method can choose to use the exception information in some way or to ignore it by doing nothing and returning None as a result.
 __exit__() 方法能自己决定怎样利用这个异常信息，或者忽略它并返回一个None值

If __exit__() returns True, the exception is cleared as if nothing happened and the program continues executing statements immediately after the with block.
 如果 __exit__() 返回 True ，那么异常会被清空，就好像什么都没发生一样， with 语句后面的程序继续在正常执行

One subtle aspect of this recipe is whether or not the LazyConnection class allows nested use of the connection with multiple with statements.
还有一个细节问题就是 LazyConnection 类是否允许多个 with 语句来嵌套使用连接

As shown, only a single socket connection at a time is allowed, and an exception is raised if a repeated with statement is attempted when a socket is already in use.
 很显然，上面的定义中一次只能允许一个socket连接，如果正在使用一个socket的时候又重复使用 with 语句， 就会产生一个异常了

You can work around this limitation with a slightly different implementation, as shown here:
不过你可以像下面这样修改下上面的实现来解决这个问题：

In this second version, the LazyConnection class serves as a kind of factory for connections.
在第二个版本中，LazyConnection 类可以被看做是某个连接工厂

Internally, a list is used to keep a stack.
在内部，一个列表被用来构造一个栈

Whenever __enter__() executes, it makes a new connection and adds it to the stack.
 每次 __enter__() 方法执行的时候，它复制创建一个新的连接并将其加入到栈里面

The __exit__() method simply pops the last connection off the stack and closes it.
 __exit__() 方法简单的从栈中弹出最后一个连接并关闭它

It’s subtle, but this allows multiple connections to be created at once with nested with statements, as shown.
 这里稍微有点难理解，不过它能允许嵌套使用 with 语句创建多个连接，就如上面演示的那样

Context managers are most commonly used in programs that need to manage resources such as files, network connections, and locks.
在需要管理一些资源比如文件、网络连接和锁的编程环境中，使用上下文管理器是很普遍的

A key part of such resources is they have to be explicitly closed or released to operate correctly.
 这些资源的一个主要特征是它们必须被手动的关闭或释放来确保程序的正确运行

For instance, if you acquire a lock, then you have to make sure you release it, or else you risk deadlock.
 例如，如果你请求了一个锁，那么你必须确保之后释放了它，否则就可能产生死锁

By implementing __enter__(), __exit__(), and using the with statement, it is much easier to avoid such problems, since the cleanup code in the __exit__() method is guaranteed to run no matter what.
 通过实现 __enter__() 和 __exit__() 方法并使用 with 语句可以很容易的避免这些问题， 因为 __exit__() 方法可以让你无需担心这些了

An alternative formulation of context managers is found in the contextmanager module.
在 contextmanager 模块中有一个标准的上下文管理方案模板，可参考9.22小节

See “Defining Context Managers the Easy Way”.
 同时在12.6小节中还有一个对本节示例程序的线程安全的修改版

Saving Memory When Creating a Large Number of Instances
8.4 创建大量对象时节省内存方法¶

Your program creates a large number (e.g., millions) of instances and uses a large amount of memory.
你的程序要创建大量(可能上百万)的对象，导致占用很大的内存

For classes that primarily serve as simple data structures, you can often greatly reduce the memory footprint of instances by adding the __slots__ attribute to the class definition.
对于主要是用来当成简单的数据结构的类而言，你可以通过给类添加 __slots__ 属性来极大的减少实例所占的内存

For example:
比如：

When you define __slots__, Python uses a much more compact internal representation for instances.
当你定义 __slots__ 后，Python就会为实例使用一种更加紧凑的内部表示

Instead of each instance consisting of a dictionary, instances are built around a small fixed-sized array, much like a tuple or list.
 实例通过一个很小的固定大小的数组来构建，而不是为每个实例定义一个字典，这跟元组或列表很类似

Attribute names listed in the __slots__ specifier are internally mapped to specific indices within this array.
 在 __slots__ 中列出的属性名在内部被映射到这个数组的指定小标上

A side effect of using slots is that it is no longer possible to add new attributes to instances—you are restricted to only those attribute names listed in the __slots__ specifier.
 使用slots一个不好的地方就是我们不能再给实例添加新的属性了，只能使用在 __slots__ 中定义的那些属性名

The memory saved by using slots varies according to the number and type of attributes stored.
使用slots后节省的内存会跟存储属性的数量和类型有关

However, in general, the resulting memory use is comparable to that of storing data in a tuple.
 不过，一般来讲，使用到的内存总量和将数据存储在一个元组中差不多

To give you an idea, storing a single Date instance without slots requires 428 bytes of memory on a 64-bit version of Python.
 为了给你一个直观认识，假设你不使用slots直接存储一个Date实例， 在64位的Python上面要占用428字节，而如果使用了slots，内存占用下降到156字节

If slots is defined, it drops to 156 bytes.
 如果程序中需要同时创建大量的日期实例，那么这个就能极大的减小内存使用量了

Although slots may seem like a feature that could be generally useful, you should resist the urge to use it in most code.
尽管slots看上去是一个很有用的特性，很多时候你还是得减少对它的使用冲动

There are many parts of Python that rely on the normal dictionary-based implementation.
 Python的很多特性都依赖于普通的基于字典的实现

In addition, classes that define slots don’t support certain features such as multiple inheritance.
 另外，定义了slots后的类不再支持一些普通类特性了，比如多继承

For the most part, you should only use slots on classes that are going to serve as frequently used data structures in your program (e.g., if your program created millions of instances of a particular class).
 大多数情况下，你应该只在那些经常被使用到的用作数据结构的类上定义slots (比如在程序中需要创建某个类的几百万个实例对象)

A common misperception of __slots__ is that it is an encapsulation tool that prevents users from adding new attributes to instances.
关于 __slots__ 的一个常见误区是它可以作为一个封装工具来防止用户给实例增加新的属性

Although this is a side effect of using slots, this was never the original purpose.
 尽管使用slots可以达到这样的目的，但是这个并不是它的初衷

Instead, __slots__ was always intended to be an optimization tool.
 __slots__ 更多的是用来作为一个内存优化工具

Encapsulating Names in a Class
8.5 在类中封装属性名¶

You want to encapsulate "private" data on instances of a class, but are concerned about Python’s lack of access control.
你想封装类的实例上面的“私有”数据，但是Python语言并没有访问控制

Rather than relying on language features to encapsulate data, Python programmers are expected to observe certain naming conventions concerning the intended usage of data and methods.
Python程序员不去依赖语言特性去封装数据，而是通过遵循一定的属性和方法命名规约来达到这个效果

The first convention is that any name that starts with a single leading underscore (_) should always be assumed to be internal implementation.
 第一个约定是任何以单下划线_开头的名字都应该是内部实现

For example:
比如：

Python doesn’t actually prevent someone from accessing internal names.
Python并不会真的阻止别人访问内部名称

However, doing so is considered impolite, and may result in fragile code.
但是如果你这么做肯定是不好的，可能会导致脆弱的代码

It should be noted, too, that the use of the leading underscore is also used for module names and module-level functions.
 同时还要注意到，使用下划线开头的约定同样适用于模块名和模块级别函数

For example, if you ever see a module name that starts with a leading underscore (e.g., _socket), it’s internal implementation.
 例如，如果你看到某个模块名以单下划线开头(比如_socket)，那它就是内部实现

Likewise, module-level functions such as sys._getframe() should only be used with great caution.
 类似的，模块级别函数比如 sys._getframe() 在使用的时候就得加倍小心了

You may also encounter the use of two leading underscores (__) on names within class definitions.
你还可能会遇到在类定义中使用两个下划线(__)开头的命名

For example:
比如：

The use of double leading underscores causes the name to be mangled to something else.
使用双下划线开始会导致访问名称变成其他形式

Specifically, the private attributes in the preceding class get renamed to _B__private and _B__private_method, respectively.
 比如，在前面的类B中，私有属性会被分别重命名为 _B__private 和 _B__private_method 

At this point, you might ask what purpose such name mangling serves.
 这时候你可能会问这样重命名的目的是什么，答案就是继承——这种属性通过继承是无法被覆盖的

The answer is inheritance—such attributes cannot be overridden via inheritance.
比如：

Here, the private names __private and __private_method get renamed to _C__private and _C__private_method, which are different than the mangled names in the base class B.
这里，私有名称 __private 和 __private_method 被重命名为 _C__private 和 _C__private_method ，这个跟父类B中的名称是完全不同的

The fact that there are two different conventions (single underscore versus double underscore) for "private" attributes leads to the obvious question of which style you should use.
上面提到有两种不同的编码约定(单下划线和双下划线)来命名私有属性，那么问题就来了：到底哪种方式好呢

For most code, you should probably just make your nonpublic names start with a single underscore.
 大多数而言，你应该让你的非公共名称以单下划线开头

If, however, you know that your code will involve subclassing, and there are internal attributes that should be hidden from subclasses, use the double underscore instead.
但是，如果你清楚你的代码会涉及到子类， 并且有些内部属性应该在子类中隐藏起来，那么才考虑使用双下划线方案

It should also be noted that sometimes you may want to define a variable that clashes with the name of a reserved word.
还有一点要注意的是，有时候你定义的一个变量和某个保留关键字冲突，这时候可以使用单下划线作为后缀，例如：

The reason for not using a leading underscore here is that it avoids confusion about the intended usage (i.e., the use of a leading underscore could be interpreted as a way to avoid a name collision rather than as an indication that the value is private).
这里我们并不使用单下划线前缀的原因是它避免误解它的使用初衷 (如使用单下划线前缀的目的是为了防止命名冲突而不是指明这个属性是私有的)

Using a single trailing underscore solves this problem.
 通过使用单下划线后缀可以解决这个问题

Creating Managed Attributes
8.6 创建可管理的属性¶

You want to add extra processing (e.g., type checking or validation) to the getting or setting of an instance attribute.
你想给某个实例attribute增加除访问与修改之外的其他处理逻辑，比如类型检查或合法性验证

A simple way to customize access to an attribute is to define it as a "property." For example, this code defines a property that adds simple type checking to an attribute:
自定义某个属性的一种简单方法是将它定义为一个property

In the preceding code, there are three related methods, all of which must have the same name.
上述代码中有三个相关联的方法，这三个方法的名字都必须一样

The first method is a getter function, and establishes first_name as being a property.
 第一个方法是一个 getter 函数，它使得 first_name 成为一个属性

The other two methods attach optional setter and deleter functions to the first_name property.
 其他两个方法给 first_name 属性添加了 setter 和 deleter 函数

It’s important to stress that the @first_name.setter and @first_name.deleter decorators won’t be defined unless first_name was already established as a property using @property.
 需要强调的是只有在 first_name 属性被创建后， 后面的两个装饰器 @first_name.setter 和 @first_name.deleter 才能被定义

A critical feature of a property is that it looks like a normal attribute, but access automatically triggers the getter, setter, and deleter methods.
property的一个关键特征是它看上去跟普通的attribute没什么两样， 但是访问它的时候会自动触发 getter 、setter 和 deleter 方法

For example:
例如：

When implementing a property, the underlying data (if any) still needs to be stored somewhere.
在实现一个property的时候，底层数据(如果有的话)仍然需要存储在某个地方

Thus, in the get and set methods, you see direct manipulation of a _first_name attribute, which is where the actual data lives.
 因此，在get和set方法中，你会看到对 _first_name 属性的操作，这也是实际数据保存的地方

In addition, you may ask why the __init__() method sets self.first_name instead of self._first_name.
 另外，你可能还会问为什么 __init__() 方法中设置了 self.first_name 而不是 self._first_name 

In this example, the entire point of the property is to apply type checking when setting an attribute.
 在这个例子中，我们创建一个property的目的就是在设置attribute的时候进行检查

Thus, chances are you would also want such checking to take place during initialization.
 因此，你可能想在初始化的时候也进行这种类型检查

By setting self.first_name, the set operation uses the setter method (as opposed to bypassing it by accessing self._first_name).
通过设置 self.first_name ，自动调用 setter 方法， 这个方法里面会进行参数的检查，否则就是直接访问 self._first_name 了

Properties can also be defined for existing get and set methods.
还能在已存在的get和set方法基础上定义property

For example:
例如：

A property attribute is actually a collection of methods bundled together.
一个property属性其实就是一系列相关绑定方法的集合

If you inspect a class with a property, you can find the raw methods in the fget, fset, and fdel attributes of the property itself.
如果你去查看拥有property的类， 就会发现property本身的fget、fset和fdel属性就是类里面的普通方法

For example:
比如：

Normally, you wouldn’t call fget or fset directly, but they are triggered automatically when the property is accessed.
通常来讲，你不会直接取调用fget或者fset，它们会在访问property的时候自动被触发

Properties should only be used in cases where you actually need to perform extra processing on attribute access.
只有当你确实需要对attribute执行其他额外的操作的时候才应该使用到property

Sometimes programmers coming from languages such as Java feel that all access should be handled by getters and setters, and that they should write code like this:
 有时候一些从其他编程语言(比如Java)过来的程序员总认为所有访问都应该通过getter和setter， 所以他们认为代码应该像下面这样写：

Don’t write properties that don’t actually add anything extra like this.
不要写这种没有做任何其他额外操作的property

For one, it makes your code more verbose and confusing to others.
 首先，它会让你的代码变得很臃肿，并且还会迷惑阅读者

Second, it will make your program run a lot slower.
 其次，它还会让你的程序运行起来变慢很多

Lastly, it offers no real design benefit.
 最后，这样的设计并没有带来任何的好处

Specifically, if you later decide that extra processing needs to be added to the handling of an ordinary attribute, you could promote it to a property without changing existing code.
 特别是当你以后想给普通attribute访问添加额外的处理逻辑的时候， 你可以将它变成一个property而无需改变原来的代码

This is because the syntax of code that accessed the attribute would remain unchanged.
 因为访问attribute的代码还是保持原样

Properties can also be a way to define computed attributes.
Properties还是一种定义动态计算attribute的方法

These are attributes that are not actually stored, but computed on demand.
 这种类型的attributes并不会被实际的存储，而是在需要的时候计算出来

For example:
比如：

Here, the use of properties results in a very uniform instance interface in that radius, area, and perimeter are all accessed as simple attributes, as opposed to a mix of simple attributes and method calls.
在这里，我们通过使用properties，将所有的访问接口形式统一起来， 对半径、直径、周长和面积的访问都是通过属性访问，就跟访问简单的attribute是一样的

For example:
 如果不这样做的话，那么就要在代码中混合使用简单属性访问和方法调用

Although properties give you an elegant programming interface, sometimes you actually may want to directly use getter and setter functions.
尽管properties可以实现优雅的编程接口，但有些时候你还是会想直接使用getter和setter函数

For example:
例如：

This often arises in situations where Python code is being integrated into a larger infrastructure of systems or programs.
这种情况的出现通常是因为Python代码被集成到一个大型基础平台架构或程序中

For example, perhaps a Python class is going to be plugged into a large distributed system based on remote procedure calls or distributed objects.
 例如，有可能是一个Python类准备加入到一个基于远程过程调用的大型分布式系统中

In such a setting, it may be much easier to work with an explicit get/set method (as a normal method call) rather than a property that implicitly makes such calls.
 这种情况下，直接使用get/set方法(普通方法调用)而不是property或许会更容易兼容

Last, but not least, don’t write Python code that features a lot of repetitive property definitions.
最后一点，不要像下面这样写有大量重复代码的property定义：

Code repetition leads to bloated, error prone, and ugly code.
重复代码会导致臃肿、易出错和丑陋的程序

As it turns out, there are much better ways to achieve the same thing using descriptors or closures.
好消息是，通过使用装饰器或闭包，有很多种更好的方法来完成同样的事情

See Recipes and .
 可以参考8.9和9.21小节的内容

Calling a Method on a Parent Class
8.7 调用父类方法¶

You want to invoke a method in a parent class in place of a method that has been overridden in a subclass.
你想在子类中调用父类的某个已经被覆盖的方法

To call a method in a parent (or superclass), use the super() function.
为了调用父类(超类)的一个方法，可以使用 super() 函数，比如：

A very common use of super() is in the handling of the __init__() method to make sure that parents are properly initialized:
super() 函数的一个常见用法是在 __init__() 方法中确保父类被正确的初始化了：

Another common use of super() is in code that overrides any of Python’s special methods.
super() 的另外一个常见用法出现在覆盖Python特殊方法的代码中，比如：

In this code, the implementation of __setattr__() includes a name check.
在上面代码中，__setattr__() 的实现包含一个名字检查

If the name starts with an underscore (_), it invokes the original implementation of __setattr__() using super().
 如果某个属性名以下划线(_)开头，就通过 super() 调用原始的 __setattr__() ， 否则的话就委派给内部的代理对象 self._obj 去处理

Otherwise, it delegates to the internally held object self._obj.
 这看上去有点意思，因为就算没有显式的指明某个类的父类， super() 仍然可以有效的工作

Correct use of the super() function is actually one of the most poorly understood aspects of Python.
实际上，大家对于在Python中如何正确使用 super() 函数普遍知之甚少

Occasionally, you will see code written that directly calls a method in a parent like this:
 你有时候会看到像下面这样直接调用父类的一个方法：

Although this "works" for most code, it can lead to bizarre trouble in advanced code involving multiple inheritance.
尽管对于大部分代码而言这么做没什么问题，但是在更复杂的涉及到多继承的代码中就有可能导致很奇怪的问题发生

For example, consider the following:
 比如，考虑如下的情况：

If you run this code, you’ll see that the Base.__init__() method gets invoked twice, as shown here:
如果你运行这段代码就会发现 Base.__init__() 被调用两次，如下所示：

Perhaps double-invocation of Base.__init__() is harmless, but perhaps not.
可能两次调用 Base.__init__() 没什么坏处，但有时候却不是

If, on the other hand, you change the code to use super(), it all works:
 另一方面，假设你在代码中换成使用 super() ，结果就很完美了：

When you use this new version, you’ll find that each __init__() method only gets called once:
运行这个新版本后，你会发现每个 __init__() 方法只会被调用一次了：

To understand why it works, we need to step back for a minute and discuss how Python implements inheritance.
为了弄清它的原理，我们需要花点时间解释下Python是如何实现继承的

For every class that you define, Python computes what’s known as a method resolution order (MRO) list.
 对于你定义的每一个类，Python会计算出一个所谓的方法解析顺序(MRO)列表

The MRO list is simply a linear ordering of all the base classes.
 这个MRO列表就是一个简单的所有基类的线性顺序表

For example:
例如：

To implement inheritance, Python starts with the leftmost class and works its way left-to-right through classes on the MRO list until it finds the first attribute match.
为了实现继承，Python会在MRO列表上从左到右开始查找基类，直到找到第一个匹配这个属性的类为止

The actual determination of the MRO list itself is made using a technique known as C3 Linearization.
而这个MRO列表的构造是通过一个C3线性化算法来实现的

Without getting too bogged down in the mathematics of it, it is actually a merge sort of the MROs from the parent classes subject to three constraints:
 我们不去深究这个算法的数学原理，它实际上就是合并所有父类的MRO列表并遵循如下三条准则：

Honestly, all you really need to know is that the order of classes in the MRO list "makes sense" for almost any class hierarchy you are going to define.
老实说，你所要知道的就是MRO列表中的类顺序会让你定义的任意类层级关系变得有意义

When you use the super() function, Python continues its search starting with the next class on the MRO.
当你使用 super() 函数时，Python会在MRO列表上继续搜索下一个类

As long as every redefined method consistently uses super() and only calls it once, control will ultimately work its way through the entire MRO list and each method will only be called once.
 只要每个重定义的方法统一使用 super() 并只调用它一次， 那么控制流最终会遍历完整个MRO列表，每个方法也只会被调用一次

This is why you don’t get double calls to Base.__init__() in the second example.
 这也是为什么在第二个例子中你不会调用两次 Base.__init__() 的原因

A somewhat surprising aspect of super() is that it doesn’t necessarily go to the direct parent of a class next in the MRO and that you can even use it in a class with no direct parent at all.
super() 有个令人吃惊的地方是它并不一定去查找某个类在MRO中下一个直接父类， 你甚至可以在一个没有直接父类的类中使用它

For example, consider this class:
例如，考虑如下这个类：

If you try to use this class, you’ll find that it’s completely broken:
如果你试着直接使用这个类就会出错：

Yet, watch what happens if you start using the class with multiple inheritance:
但是，如果你使用多继承的话看看会发生什么：

Here you see that the use of super().spam() in class A has, in fact, called the spam() method in class B—a class that is completely unrelated to A!
你可以看到在类A中使用 super().spam() 实际上调用的是跟类A毫无关系的类B中的 spam() 方法

This is all explained by the MRO of class C:
 这个用类C的MRO列表就可以完全解释清楚了：

Using super() in this manner is most common when defining mixin classes.
在定义混入类的时候这样使用 super() 是很普遍的

See Recipes and .
可以参考8.13和8.18小节

However, because super() might invoke a method that you’re not expecting, there are a few general rules of thumb you should try to follow.
然而，由于 super() 可能会调用不是你想要的方法，你应该遵循一些通用原则

First, make sure that all methods with the same name in an inheritance hierarchy have a compatible calling signature (i.e., same number of arguments, argument names).
 首先，确保在继承体系中所有相同名字的方法拥有可兼容的参数签名(比如相同的参数个数和参数名称)

This ensures that super() won’t get tripped up if it tries to invoke a method on a class that’s not a direct parent.
 这样可以确保 super() 调用一个非直接父类方法时不会出错

Second, it’s usually a good idea to make sure that the topmost class provides an implementation of the method so that the chain of lookups that occur along the MRO get terminated by an actual method of some sort.
 其次，最好确保最顶层的类提供了这个方法的实现，这样的话在MRO上面的查找链肯定可以找到某个确定的方法

Use of super() is sometimes a source of debate in the Python community.
在Python社区中对于 super() 的使用有时候会引来一些争议

However, all things being equal, you should probably use it in modern code.
 尽管如此，如果一切顺利的话，你应该在你最新代码中使用它

Raymond Hettinger has written an excellent blog post "Python’s super() Considered Super!" that has even more examples and reasons why super() might be super-awesome.
 Raymond Hettinger为此写了一篇非常好的文章 “Python’s super() Considered Super!” ， 通过大量的例子向我们解释了为什么 super() 是极好的

Extending a Property in a Subclass
8.8 子类中扩展property¶

Within a subclass, you want to extend the functionality of a property defined in a parent class.
在子类中，你想要扩展定义在父类中的property的功能

Consider the following code, which defines a property:
考虑如下的代码，它定义了一个property：

Here is an example of a class that inherits from Person and extends the name property with new functionality:
下面是一个示例类，它继承自Person并扩展了 name 属性的功能：

Here is an example of the new class in use:
接下来使用这个新类：

If you only want to extend one of the methods of a property, use code such as the following:
如果你仅仅只想扩展property的某一个方法，那么可以像下面这样写：

Or, alternatively, for just the setter, use this code:
或者，你只想修改setter方法，就这么写：

Extending a property in a subclass introduces a number of very subtle problems related to the fact that a property is defined as a collection of getter, setter, and deleter methods, as opposed to just a single method.
在子类中扩展一个property可能会引起很多不易察觉的问题， 因为一个property其实是 getter、setter 和 deleter 方法的集合，而不是单个方法

Thus, when extending a property, you need to figure out if you will redefine all of the methods together or just one of the methods.
 因此，但你扩展一个property的时候，你需要先确定你是否要重新定义所有的方法还是说只修改其中某一个

In the first example, all of the property methods are redefined together.
在第一个例子中，所有的property方法都被重新定义

Within each method, super() is used to call the previous implementation.
 在每一个方法中，使用了 super() 来调用父类的实现

The use of super(SubPerson, SubPerson).name.__set__(self, value) in the setter function is no mistake.
 在 setter 函数中使用 super(SubPerson, SubPerson).name.__set__(self, value) 的语句是没有错的

To delegate to the previous implementation of the setter, control needs to pass through the __set__() method of the previously defined name property.
 为了委托给之前定义的setter方法，需要将控制权传递给之前定义的name属性的 __set__() 方法

However, the only way to get to this method is to access it as a class variable instead of an instance variable.
 不过，获取这个方法的唯一途径是使用类变量而不是实例变量来访问它

This is what happens with the super(SubPerson, SubPerson) operation.
 这也是为什么我们要使用 super(SubPerson, SubPerson) 的原因

If you only want to redefine one of the methods, it’s not enough to use @property by itself.
如果你只想重定义其中一个方法，那只使用 @property 本身是不够的

For example, code like this doesn’t work:
比如，下面的代码就无法工作：

If you try the resulting code, you’ll find that the setter function disappears entirely:
如果你试着运行会发现setter函数整个消失了：

Instead, you should change the code to that shown in the solution:
你应该像之前说过的那样修改代码：

When you do this, all of the previously defined methods of the property are copied, and the getter function is replaced.
这么写后，property之前已经定义过的方法会被复制过来，而getter函数被替换

It now works as expected:
然后它就能按照期望的工作了：

In this particular solution, there is no way to replace the hardcoded class name Person with something more generic.
在这个特别的解决方案中，我们没办法使用更加通用的方式去替换硬编码的 Person 类名

If you don’t know which base class defined a property, you should use the solution where all of the property methods are redefined and super() is used to pass control to the previous implementation.
 如果你不知道到底是哪个基类定义了property， 那你只能通过重新定义所有property并使用 super() 来将控制权传递给前面的实现

It’s worth noting that the first technique shown in this recipe can also be used to extend a descriptor, as described in “Creating a New Kind of Class or Instance Attribute”.
值的注意的是上面演示的第一种技术还可以被用来扩展一个描述器(在8.9小节我们有专门的介绍)

For example:
比如：

Finally, it’s worth noting that by the time you read this, subclassing of setter and deleter methods might be somewhat simplified.
最后值的注意的是，读到这里时，你应该会发现子类化 setter 和 deleter 方法其实是很简单的

The solution shown will still work, but the bug reported at Python’s issues page might resolve into a cleaner approach in a future Python version.
 这里演示的解决方案同样适用，但是在 Python的issue页面 报告的一个bug，或许会使得将来的Python版本中出现一个更加简洁的方法

Creating a New Kind of Class or Instance Attribute
8.9 创建新的类或实例属性¶

You want to create a new kind of instance attribute type with some extra functionality, such as type checking.
你想创建一个新的拥有一些额外功能的实例属性类型，比如类型检查

If you want to create an entirely new kind of instance attribute, define its functionality in the form of a descriptor class.
如果你想创建一个全新的实例属性，可以通过一个描述器类的形式来定义它的功能

Here is an example:
下面是一个例子：

A descriptor is a class that implements the three core attribute access operations (get, set, and delete) in the form of __get__(), __set__(), and __delete__() special methods.
一个描述器就是一个实现了三个核心的属性访问操作(get, set, delete)的类， 分别为 __get__() 、__set__() 和 __delete__() 这三个特殊的方法

These methods work by receiving an instance as input.
 这些方法接受一个实例作为输入，之后相应的操作实例底层的字典

To use a descriptor, instances of the descriptor are placed into a class definition as class variables.
为了使用一个描述器，需将这个描述器的实例作为类属性放到一个类的定义中

For example:
例如：

When you do this, all access to the descriptor attributes (e.g., x or y) is captured by the __get__(), __set__(), and __delete__() methods.
当你这样做后，所有对描述器属性(比如x或y)的访问会被 __get__() 、__set__() 和 __delete__() 方法捕获到

For example:
例如：

As input, each method of a descriptor receives the instance being manipulated.
作为输入，描述器的每一个方法会接受一个操作实例

To carry out the requested operation, the underlying instance dictionary (the __dict__ attribute) is manipulated as appropriate.
 为了实现请求操作，会相应的操作实例底层的字典(__dict__属性)

The self.name attribute of the descriptor holds the dictionary key being used to store the actual data in the instance dictionary.
 描述器的 self.name 属性存储了在实例字典中被实际使用到的key

Descriptors provide the underlying magic for most of Python’s class features, including @classmethod, @staticmethod, @property, and even the __slots__ specification.
描述器可实现大部分Python类特性中的底层魔法， 包括 @classmethod 、@staticmethod 、@property ，甚至是 __slots__ 特性

By defining a descriptor, you can capture the core instance operations (get, set, delete) at a very low level and completely customize what they do.
通过定义一个描述器，你可以在底层捕获核心的实例操作(get, set, delete)，并且可完全自定义它们的行为

This gives you great power, and is one of the most important tools employed by the writers of advanced libraries and frameworks.
 这是一个强大的工具，有了它你可以实现很多高级功能，并且它也是很多高级库和框架中的重要工具之一

One confusion with descriptors is that they can only be defined at the class level, not on a per-instance basis.
描述器的一个比较困惑的地方是它只能在类级别被定义，而不能为每个实例单独定义

Thus, code like this will not work:
因此，下面的代码是无法工作的：

Also, the implementation of the __get__() method is trickier than it seems:
同时，__get__() 方法实现起来比看上去要复杂得多：

The reason __get__() looks somewhat complicated is to account for the distinction between instance variables and class variables.
__get__() 看上去有点复杂的原因归结于实例变量和类变量的不同

If a descriptor is accessed as a class variable, the instance argument is set to None.
 如果一个描述器被当做一个类变量来访问，那么 instance 参数被设置成 None 

In this case, it is standard practice to simply return the descriptor instance itself (although any kind of custom processing is also allowed).
 这种情况下，标准做法就是简单的返回这个描述器本身即可(尽管你还可以添加其他的自定义操作)

For example:
例如：

Descriptors are often just one component of a larger programming framework involving decorators or metaclasses.
描述器通常是那些使用到装饰器或元类的大型框架中的一个组件

As such, their use may be hidden just barely out of sight.
同时它们的使用也被隐藏在后面

As an example, here is some more advanced descriptor-based code involving a class decorator:
 举个例子，下面是一些更高级的基于描述器的代码，并涉及到一个类装饰器：

Finally, it should be stressed that you would probably not write a descriptor if you simply want to customize the access of a single attribute of a specific class.
最后要指出的一点是，如果你只是想简单的自定义某个类的单个属性访问的话就不用去写描述器了

For that, it’s easier to use a property instead, as described in “Creating Managed Attributes”.
 这种情况下使用8.6小节介绍的property技术会更加容易

Descriptors are more useful in situations where there will be a lot of code reuse (i.e., you want to use the functionality provided by the descriptor in hundreds of places in your code or provide it as a library feature).
 当程序中有很多重复代码的时候描述器就很有用了 (比如你想在你代码的很多地方使用描述器提供的功能或者将它作为一个函数库特性)

Using Lazily Computed Properties
8.10 使用延迟计算属性¶

You’d like to define a read-only attribute as a property that only gets computed on access.
你想将一个只读属性定义成一个property，并且只在访问的时候才会计算结果

However, once accessed, you’d like the value to be cached and not recomputed on each access.
 但是一旦被访问后，你希望结果值被缓存起来，不用每次都去计算

An efficient way to define a lazy attribute is through the use of a descriptor class, such as the following:
定义一个延迟属性的一种高效方法是通过使用一个描述器类，如下所示：

To utilize this code, you would use it in a class such as the following:
你需要像下面这样在一个类中使用它：

Here is an interactive session that illustrates how it works:
下面在一个交互环境中演示它的使用：

Carefully observe that the messages "Computing area" and "Computing perimeter" only appear once.
仔细观察你会发现消息 Computing area 和 Computing perimeter 仅仅出现一次

In many cases, the whole point of having a lazily computed attribute is to improve performance.
很多时候，构造一个延迟计算属性的主要目的是为了提升性能

For example, you avoid computing values unless you actually need them somewhere.
 例如，你可以避免计算这些属性值，除非你真的需要它们

The solution shown does just this, but it exploits a subtle feature of descriptors to do it in a highly efficient way.
 这里演示的方案就是用来实现这样的效果的， 只不过它是通过以非常高效的方式使用描述器的一个精妙特性来达到这种效果的

As shown in other recipes (e.g., “Creating a New Kind of Class or Instance Attribute”), when a descriptor is placed into a class definition, its __get__(), __set__(), and __delete__() methods get triggered on attribute access.
正如在其他小节(如8.9小节)所讲的那样，当一个描述器被放入一个类的定义时， 每次访问属性时它的 __get__() 、__set__() 和 __delete__() 方法就会被触发

However, if a descriptor only defines a __get__() method, it has a much weaker binding than usual.
 不过，如果一个描述器仅仅只定义了一个 __get__() 方法的话，它比通常的具有更弱的绑定

In particular, the __get__() method only fires if the attribute being accessed is not in the underlying instance dictionary.
 特别地，只有当被访问属性不在实例底层的字典中时 __get__() 方法才会被触发

The lazyproperty class exploits this by having the __get__() method store the computed value on the instance using the same name as the property itself.
lazyproperty 类利用这一点，使用 __get__() 方法在实例中存储计算出来的值， 这个实例使用相同的名字作为它的property

By doing this, the value gets stored in the instance dictionary and disables further computation of the property.
 这样一来，结果值被存储在实例字典中并且以后就不需要再去计算这个property了

You can observe this by digging a little deeper into the example:
 你可以尝试更深入的例子来观察结果：

One possible downside to this recipe is that the computed value becomes mutable after it’s created.
这种方案有一个小缺陷就是计算出的值被创建后是可以被修改的

For example:
例如：

If that’s a concern, you can use a slightly less efficient implementation, like this:
如果你担心这个问题，那么可以使用一种稍微没那么高效的实现，就像下面这样：

If you use this version, you’ll find that set operations are not allowed.
如果你使用这个版本，就会发现现在修改操作已经不被允许了：

However, a disadvantage is that all get operations have to be routed through the property’s getter function.
然而，这种方案有一个缺点就是所有get操作都必须被定向到属性的 getter 函数上去

This is less efficient than simply looking up the value in the instance dictionary, as was done in the original solution.
 这个跟之前简单的在实例字典中查找值的方案相比效率要低一点

For more information on properties and managed attributes, see “Creating Managed Attributes”.
 如果想获取更多关于property和可管理属性的信息，可以参考8.6小节

Descriptors are described in “Creating a New Kind of Class or Instance Attribute”.
而描述器的相关内容可以在8.9小节找到

Simplifying the Initialization of Data Structures
8.11 简化数据结构的初始化¶

You are writing a lot of classes that serve as data structures, but you are getting tired of writing highly repetitive and boilerplate __init__() functions.
你写了很多仅仅用作数据结构的类，不想写太多烦人的 __init__() 函数

You can often generalize the initialization of data structures into a single __init__() function defined in a common base class.
可以在一个基类中写一个公用的 __init__() 函数：

If you use the resulting classes, you’ll find that they are easy to construct.
然后使你的类继承自这个基类

For example:
使用这些类的示例：

Should you decide to support keyword arguments, there are several design options.
如果还想支持关键字参数，可以将关键字参数设置为实例属性：

Another possible choice is to use keyword arguments as a means for adding additional attributes to the structure not specified in _fields.
你还能将不在 _fields 中的名称加入到属性中去：

This technique of defining a general purpose __init__() method can be extremely useful if you’re ever writing a program built around a large number of small data structures.
当你需要使用大量很小的数据结构类的时候， 相比手工一个个定义 __init__() 方法而已，使用这种方式可以大大简化代码

One subtle aspect of the implementation concerns the mechanism used to set value using the setattr() function.
在上面的实现中我们使用了 setattr() 函数类设置属性值， 你可能不想用这种方式，而是想直接更新实例字典，就像下面这样：

Although this works, it’s often not safe to make assumptions about the implementation of a subclass.
尽管这也可以正常工作，但是当定义子类的时候问题就来了

If a subclass decided to use __slots__ or wrap a specific attribute with a property (or descriptor), directly acccessing the instance dictionary would break.
 当一个子类定义了 __slots__ 或者通过property(或描述器)来包装某个属性， 那么直接访问实例字典就不起作用了

The solution has been written to be as general purpose as possible and not to make any assumptions about subclasses.
我们上面使用 setattr() 会显得更通用些，因为它也适用于子类情况

A potential downside of this technique is that it impacts documentation and help features of IDEs.
这种方法唯一不好的地方就是对某些IDE而已，在显示帮助函数时可能不太友好

If a user asks for help on a specific class, the required arguments aren’t described in the usual way.
比如：

It should be noted that it is also possible to automatically initialize instance variables using a utility function and a so-called "frame hack." For example:
可以参考9.16小节来强制在 __init__() 方法中指定参数的类型签名

Defining an Interface or Abstract Base Class
8.12 定义接口或者抽象基类¶

You want to define a class that serves as an interface or abstract base class from which you can perform type checking and ensure that certain methods are implemented in subclasses.
你想定义一个接口或抽象类，并且通过执行类型检查来确保子类实现了某些特定的方法

To define an abstract base class, use the abc module.
使用 abc 模块可以很轻松的定义抽象基类：

A central feature of an abstract base class is that it cannot be instantiated directly.
抽象类的一个特点是它不能直接被实例化，比如你想像下面这样做是不行的：

Instead, an abstract base class is meant to be used as a base class for other classes that are expected to implement the required methods.
抽象类的目的就是让别的类继承它并实现特定的抽象方法：

A major use of abstract base classes is in code that wants to enforce an expected programming interface.
抽象基类的一个主要用途是在代码中检查某些类是否为特定类型，实现了特定接口：

You might think that this kind of type checking only works by subclassing the abstract base class (ABC), but ABCs allow other classes to be registered as implementing the required interface.
除了继承这种方式外，还可以通过注册方式来让某个类实现抽象基类：

It should be noted that @abstractmethod can also be applied to static methods, class methods, and properties.
@abstractmethod 还能注解静态方法、类方法和 properties 

You just need to make sure you apply it in the proper sequence where @abstractmethod appears immediately before the function definition, as shown here:
 你只需保证这个注解紧靠在函数定义前即可：

Predefined abstract base classes are found in various places in the standard library.
标准库中有很多用到抽象基类的地方

The collections module defines a variety of ABCs related to containers and iterators (sequences, mappings, sets, etc.), the numbers library defines ABCs related to numeric objects (integers, floats, rationals, etc.), and the io library defines ABCs related to I/O handling.
collections 模块定义了很多跟容器和迭代器(序列、映射、集合等)有关的抽象基类

You can use the predefined ABCs to perform more generalized kinds of type checking.
你可以使用预定义的抽象类来执行更通用的类型检查，例如：

Although ABCs facilitate type checking, it’s not something that you should overuse in a program.
尽管ABCs可以让我们很方便的做类型检查，但是我们在代码中最好不要过多的使用它

At its heart, Python is a dynamic language that gives you great flexibility.
 因为Python的本质是一门动态编程语言，其目的就是给你更多灵活性， 强制类型检查或让你代码变得更复杂，这样做无异于舍本求末

Implementing a Data Model or Type System
8.13 实现数据模型的类型约束¶

You want to define various kinds of data structures, but want to enforce constraints on the values that are allowed to be assigned to certain attributes.
你想定义某些在属性赋值上面有限制的数据结构

In this problem, you are basically faced with the task of placing checks or assertions on the setting of certain instance attributes.
在这个问题中，你需要在对某些实例属性赋值时进行检查

To do this, you need to customize the setting of attributes on a per-attribute basis.
 所以你要自定义属性赋值函数，这种情况下最好使用描述器

The following code illustrates the use of descriptors to implement a system type and value checking framework:
下面的代码使用描述器实现了一个系统类型和赋值验证框架：

These classes should be viewed as basic building blocks from which you construct a data model or type system.
这些类就是你要创建的数据模型或类型系统的基础构建模块

Continuing, here is some code that implements some different kinds of data:
 下面就是我们实际定义的各种不同的数据类型：

Using these type objects, it is now possible to define a class such as this:
然后使用这些自定义数据类型，我们定义一个类：

With the constraints in place, you’ll find that assigning of attributes is now validated.
然后测试这个类的属性赋值约束，可发现对某些属性的赋值违法了约束是不合法的：

There are some techniques that can be used to simplify the specification of constraints in classes.
还有一些技术可以简化上面的代码，其中一种是使用类装饰器：

Another approach to simplify the specification of constraints is to use a metaclass.
另外一种方式是使用元类：

This recipe involves a number of advanced techniques, including descriptors, mixin classes, the use of super(), class decorators, and metaclasses.
本节使用了很多高级技术，包括描述器、混入类、super() 的使用、类装饰器和元类

Covering the basics of all those topics is beyond what can be covered here, but examples can be found in other recipes (see Recipes , , , and ).
 不可能在这里一一详细展开来讲，但是可以在8.9、8.18、9.19小节找到更多例子

However, there are a number of subtle points worth noting.
 但是，我在这里还是要提一下几个需要注意的点

First, in the Descriptor base class, you will notice that there is a __set__() method, but no corresponding __get__().
首先，在 Descriptor 基类中你会看到有个 __set__() 方法，却没有相应的 __get__() 方法

If a descriptor will do nothing more than extract an identically named value from the underlying instance dictionary, defining __get__() is unnecessary.
 如果一个描述仅仅是从底层实例字典中获取某个属性值的话，那么没必要去定义 __get__() 方法

The overall design of the various descriptor classes is based on mixin classes.
所有描述器类都是基于混入类来实现的

For example, the Unsigned and MaxSized classes are meant to be mixed with the other descriptor classes derived from Typed.
比如 Unsigned 和 MaxSized 要跟其他继承自 Typed 类混入

To handle a specific kind of data type, multiple inheritance is used to combine the desired functionality.
 这里利用多继承来实现相应的功能

You will also notice that all __init__() methods of the various descriptors have been programmed to have an identical signature involving keyword arguments **opts.
混入类的一个比较难理解的地方是，调用 super() 函数时，你并不知道究竟要调用哪个具体类

The class for MaxSized looks for its required attribute in opts, but simply passes it along to the Descriptor base class, which actually sets it.
 你需要跟其他类结合后才能正确的使用，也就是必须合作才能产生效果

The code for the class decorator and metaclass simply scan the class dictionary looking for descriptors.
使用类装饰器和元类通常可以简化代码

When found, they simply fill in the descriptor name based on the key value.
上面两个例子中你会发现你只需要输入一次属性名即可了

Of all the approaches, the class decorator solution may provide the most flexibility and sanity.
所有方法中，类装饰器方案应该是最灵活和最高明的

For one, it does not rely on any advanced machinery, such as metaclasses.
 首先，它并不依赖任何其他新的技术，比如元类

Second, decoration is something that can easily be added or removed from a class definition as desired.
其次，装饰器可以很容易的添加或删除

As a final twist, a class decorator approach can also be used as a replacement for mixin classes, multiple inheritance, and tricky use of the super() function.
最后，装饰器还能作为混入类的替代技术来实现同样的效果;

The classes defined in this alternative formulation work in exactly the same manner as before (none of the earlier example code changes) except that everything runs much faster.
这种方式定义的类跟之前的效果一样，而且执行速度会更快

For example, a simple timing test of setting a typed attribute reveals that the class decorator approach runs almost 100% faster than the approach using mixins.
 设置一个简单的类型属性的值，装饰器方式要比之前的混入类的方式几乎快100%

Now aren’t you glad you read all the way to the end?
 现在你应该庆幸自己读完了本节全部内容了吧

Implementing Custom Containers
8.14 实现自定义容器¶

You want to implement a custom class that mimics the behavior of a common built-in container type, such as a list or dictionary.
你想实现一个自定义的类来模拟内置的容器类功能，比如列表和字典

However, you’re not entirely sure what methods need to be implemented to do it.
但是你不确定到底要实现哪些方法

The collections library defines a variety of abstract base classes that are extremely useful when implementing custom container classes.
collections 定义了很多抽象基类，当你想自定义容器类的时候它们会非常有用

To illustrate, suppose you want your class to support iteration.
 比如你想让你的类支持迭代，那就让你的类继承 collections.Iterable 即可：

The special feature about inheriting from collections.Iterable is that it ensures you implement all of the required special methods.
不过你需要实现 collections.Iterable 所有的抽象方法，否则会报错:

To fix this error, simply give the class the required __iter__() method and implement it as desired (see Recipes and ).
你只要实现 __iter__() 方法就不会报错了(参考4.2和4.7小节)

Other notable classes defined in collections include Sequence, MutableSequence, Mapping, MutableMapping, Set, and MutableSet.
你可以先试着去实例化一个对象，在错误提示中可以找到需要实现哪些方法：

Here is a simple example of a class that implements the preceding methods to create a sequence where items are always stored in sorted order (it’s not a particularly efficient implementation, but it illustrates the general idea):
下面是一个简单的示例，继承自上面Sequence抽象类，并且实现元素按照顺序存储：

As you can see, instances of SortedItems behave exactly like a normal sequence and support all of the usual operations, including indexing, iteration, len(), containment (the in operator), and even slicing.
可以看到，SortedItems跟普通的序列没什么两样，支持所有常用操作，包括索引、迭代、包含判断，甚至是切片操作

As an aside, the bisect module used in this recipe is a convenient way to keep items in a list sorted.
这里面使用到了 bisect 模块，它是一个在排序列表中插入元素的高效方式

The bisect.insort() inserts an item into a list so that the list remains in order.
可以保证元素插入后还保持顺序

Inheriting from one of the abstract base classes in collections ensures that your custom container implements all of the required methods expected of the container.
使用 collections 中的抽象基类可以确保你自定义的容器实现了所有必要的方法

However, this inheritance also facilitates type checking.
并且还能简化类型检查

For example, your custom container will satisfy various type checks like this:
你的自定义容器会满足大部分类型检查需要，如下所示：

Many of the abstract base classes in collections also provide default implementations of common container methods.
collections 中很多抽象类会为一些常见容器操作提供默认的实现， 这样一来你只需要实现那些你最感兴趣的方法即可

To illustrate, suppose you have a class that inherits from collections.MutableSequence, like this:
假设你的类继承自 collections.MutableSequence ，如下：

If you create an instance of Items, you’ll find that it supports almost all of the core list methods (e.g., append(), remove(), count(), etc.).
如果你创建 Items 的实例，你会发现它支持几乎所有的核心列表方法(如append()、remove()、count()等)

These methods are implemented in such a way that they only use the required ones.
 下面是使用演示：

This recipe only provides a brief glimpse into Python’s abstract class functionality.
本小节只是对Python抽象类功能的抛砖引玉

The numbers module provides a similar collection of abstract classes related to numeric data types.
numbers 模块提供了一个类似的跟整数类型相关的抽象类型集合

See “Defining an Interface or Abstract Base Class” for more information about making your own abstract base classes.
 可以参考8.12小节来构造更多自定义抽象基类

Delegating Attribute Access
8.15 属性的代理访问¶

You want an instance to delegate attribute access to an internally held instance possibly as an alternative to inheritance or in order to implement a proxy.
你想将某个实例的属性访问代理到内部另一个实例中去，目的可能是作为继承的一个替代方法或者实现代理模式

Simply stated, delegation is a programming pattern where the responsibility for implementing a particular operation is handed off (i.e., delegated) to a different object.
简单来说，代理是一种编程模式，它将某个操作转移给另外一个对象来实现

In its simplest form, it often looks something like this:
 最简单的形式可能是像下面这样：

If there are only a couple of methods to delegate, writing code such as that just given is easy enough.
如果仅仅就两个方法需要代理，那么像这样写就足够了

However, if there are many methods to delegate, an alternative approach is to define the __getattr__() method, like this:
但是，如果有大量的方法需要代理， 那么使用 __getattr__() 方法或许或更好些：

The __getattr__() method is kind of like a catch-all for attribute lookup.
__getattr__ 方法是在访问attribute不存在的时候被调用，使用演示：

Another example of delegation is in the implementation of proxies.
另外一个代理例子是实现代理模式，例如：

To use this proxy class, you simply wrap it around another instance.
使用这个代理类时，你只需要用它来包装下其他类即可：

By customizing the implementation of the attribute access methods, you could customize the proxy to behave in different ways (e.g., logging access, only allowing read-only access, etc.).
通过自定义属性访问方法，你可以用不同方式自定义代理类行为(比如加入日志功能、只读访问等)

Delegation is sometimes used as an alternative to inheritance.
代理类有时候可以作为继承的替代方案

For example, instead of writing code like this:
例如，一个简单的继承如下：

A solution involving delegation would be written as follows:
使用代理的话，就是下面这样：

When using delegation to implement proxies, there are a few additional details to note.
当实现代理模式时，还有些细节需要注意

First, the __getattr__() method is actually a fallback method that only gets called when an attribute is not found.
 首先，__getattr__() 实际是一个后备方法，只有在属性不存在时才会调用

Thus, when attributes of the proxy instance itself are accessed (e.g., the _obj attribute), this method would not be triggered.
 因此，如果代理类实例本身有这个属性的话，那么不会触发这个方法的

Second, the __setattr__() and __delattr__() methods need a bit of extra logic added to separate attributes from the proxy instance inself and attributes on the internal object _obj.
 另外，__setattr__() 和 __delattr__() 需要额外的魔法来区分代理实例和被代理实例 _obj 的属性

A common convention is for proxies to only delegate to attributes that don’t start with a leading underscore (i.e., proxies only expose the "public" attributes of the held instance).
 一个通常的约定是只代理那些不以下划线 _ 开头的属性(代理类只暴露被代理类的公共属性)

It is also important to emphasize that the __getattr__() method usually does not apply to most special methods that start and end with double underscores.
还有一点需要注意的是，__getattr__() 对于大部分以双下划线(__)开始和结尾的属性并不适用

For example, consider this class:
 比如，考虑如下的类：

If you try to make a ListLike object, you’ll find that it supports the common list methods, such as append() and insert().
如果是创建一个ListLike对象，会发现它支持普通的列表方法，如append()和insert()， 但是却不支持len()、元素查找等

However, it does not support any of the operators like len(), item lookup, and so forth.
例如：

To support the different operators, you have to manually delegate the associated special methods yourself.
为了让它支持这些方法，你必须手动的实现这些方法代理：

See “Implementing Remote Procedure Calls” for another example of using delegation in the context of creating proxy classes for remote procedure call.
11.8小节还有一个在远程方法调用环境中使用代理的例子

Defining More Than One Constructor in a Class
8.16 在类中定义多个构造器¶

You’re writing a class, but you want users to be able to create instances in more than the one way provided by __init__().
你想实现一个类，除了使用 __init__() 方法外，还有其他方式可以初始化它

To define a class with more than one constructor, you should use a class method.
为了实现多个构造器，你需要使用到类方法

Here is a simple example:
例如：

One of the primary uses of class methods is to define alternate constructors, as shown in this recipe.
类方法的一个主要用途就是定义多个构造器

A critical feature of a class method is that it receives the class as the first argument (cls).
它接受一个 class 作为第一个参数(cls)

You will notice that this class is used within the method to create and return the final instance.
 你应该注意到了这个类被用来创建并返回最终的实例

It is extremely subtle, but this aspect of class methods makes them work correctly with features such as inheritance.
在继承时也能工作的很好：

Creating an Instance Without Invoking init
8.17 创建不调用init方法的实例¶

You need to create an instance, but want to bypass the execution of the __init__() method for some reason.
你想创建一个实例，但是希望绕过执行 __init__() 方法

A bare uninitialized instance can be created by directly calling the __new__() method of a class.
可以通过 __new__() 方法创建一个未初始化的实例

For example, consider this class:
例如考虑如下这个类：

Here’s how you can create a Date instance without invoking __init__():
下面演示如何不调用 __init__() 方法来创建这个Date实例：

As you can see, the resulting instance is uninitialized.
结果可以看到，这个Date实例的属性year还不存在，所以你需要手动初始化：

The problem of bypassing __init__() sometimes arises when instances are being created in a nonstandard way such as when deserializing data or in the implementation of a class method that’s been defined as an alternate constructor.
当我们在反序列对象或者实现某个类方法构造函数时需要绕过 __init__() 方法来创建对象

For example, on the Date class shown, someone might define an alternate constructor today() as follows:
 例如，对于上面的Date来来讲，有时候你可能会像下面这样定义一个新的构造函数 today() ：

Similarly, suppose you are deserializing JSON data and, as a result, produce a dictionary like this:
同样，在你反序列化JSON数据时产生一个如下的字典对象：

If you want to turn this into a Date instance, simply use the technique shown in the solution.
如果你想将它转换成一个Date类型实例，可以使用上面的技术

When creating instances in a nonstandard way, it’s usually best to not make too many assumptions about their implementation.
当你通过这种非常规方式来创建实例的时候，最好不要直接去访问底层实例字典，除非你真的清楚所有细节

As such, you generally don’t want to write code that directly manipulates the underlying instance dictionary __dict__ unless you know it’s guaranteed to be defined.
 否则的话，如果这个类使用了 __slots__ 、properties 、descriptors 或其他高级技术的时候代码就会失效

Otherwise, the code will break if the class uses __slots__, properties, descriptors, or other advanced techniques.
 而这时候使用 setattr() 方法会让你的代码变得更加通用

Extending Classes with Mixins
8.18 利用Mixins扩展类功能¶

You have a collection of generally useful methods that you would like to make available for extending the functionality of other class definitions.
你有很多有用的方法，想使用它们来扩展其他类的功能

However, the classes where the methods might be added aren’t necessarily related to one another via inheritance.
但是这些类并没有任何继承的关系

Thus, you can’t just attach the methods to a common base class.
 因此你不能简单的将这些方法放入一个基类，然后被其他类继承

The problem addressed by this recipe often arises in code where one is interested in the issue of class customization.
通常当你想自定义类的时候会碰上这些问题

For example, maybe a library provides a basic set of classes along with a set of optional customizations that can be applied if desired by the user.
可能是某个库提供了一些基础类， 你可以利用它们来构造你自己的类

To illustrate, suppose you have an interest in adding various customizations (e.g., logging, set-once, type checking, etc.) to mapping objects.
假设你想扩展映射对象，给它们添加日志、唯一性设置、类型检查等等功能

Here are a set of mixin classes that do that:
下面是一些混入类：

These classes, by themselves, are useless.
这些类单独使用起来没有任何意义，事实上如果你去实例化任何一个类，除了产生异常外没任何作用

In fact, if you instantiate any one of them, it does nothing useful at all (other than generate exceptions).
 它们是用来通过多继承来和其他映射对象混入使用的

Instead, they are supposed to be mixed with other mapping classes through multiple inheritance.
例如：

In the example, you will notice that the mixins are combined with other existing classes (e.g., dict, defaultdict, OrderedDict), and even one another.
这个例子中，可以看到混入类跟其他已存在的类(比如dict、defaultdict和OrderedDict)结合起来使用，一个接一个

When combined, the classes all work together to provide the desired functionality.
 结合后就能发挥正常功效了

Mixin classes appear in various places in the standard library, mostly as a means for extending the functionality of other classes similar to as shown.
混入类在标准库中很多地方都出现过，通常都是用来像上面那样扩展某些类的功能

They are also one of the main uses of multiple inheritance.
 它们也是多继承的一个主要用途

For instance, if you are writing network code, you can often use the ThreadingMixIn from the socketserver module to add thread support to other network-related classes.
比如，当你编写网络代码时候， 你会经常使用 socketserver 模块中的 ThreadingMixIn 来给其他网络相关类增加多线程支持

For example, here is a multithreaded XML-RPC server:
 例如，下面是一个多线程的XML-RPC服务：

It is also common to find mixins defined in large libraries and frameworks—again, typically to enhance the functionality of existing classes with optional features in some way.
同时在一些大型库和框架中也会发现混入类的使用，用途同样是增强已存在的类的功能和一些可选特征

There is a rich history surrounding the theory of mixin classes.
对于混入类，有几点需要记住

First, mixin classes are never meant to be instantiated directly.
首先是，混入类不能直接被实例化使用

For example, none of the classes in this recipe work by themselves.
 

Second, mixin classes typically have no state of their own.
其次，混入类没有自己的状态信息，也就是说它们并没有定义 __init__() 方法，并且没有实例属性

This means there is no __init__() method and no instance variables.
 这也是为什么我们在上面明确定义了 __slots__ = () 

In this example, you’ll notice that initializing an RDict() still takes the arguments understood by dict().
还有一种实现混入类的方式就是使用类装饰器，如下所示：

See “Implementing a Data Model or Type System” for an advanced recipe involving both mixins and class decorators.
这个效果跟之前的是一样的，而且不再需要使用多继承了

Implementing Stateful Objects or State Machines
8.19 实现状态对象或者状态机¶

You want to implement a state machine or an object that operates in a number of different states, but don’t want to litter your code with a lot of conditionals.
你想实现一个状态机或者是在不同状态下执行操作的对象，但是又不想在代码中出现太多的条件判断语句

In certain applications, you might have objects that operate differently according to some kind of internal state.
在很多程序中，有些对象会根据状态的不同来执行不同的操作

For example, consider a simple class representing a connection:
比如考虑如下的一个连接对象：

This implementation presents a couple of difficulties.
这样写有很多缺点，首先是代码太复杂了，好多的条件判断

First, the code is complicated by the introduction of many conditional checks for the state.
其次是执行效率变低， 因为一些常见的操作比如read()、write()每次执行前都需要执行检查

A more elegant approach is to encode each operational state as a separate class and arrange for the Connection class to delegate to the state class.
一个更好的办法是为每个状态定义一个对象：

Here is an interactive session that illustrates the use of these classes:
下面是使用演示：

Writing code that features a large set of complicated conditionals and intertwined states is hard to maintain and explain.
如果代码中出现太多的条件判断语句的话，代码就会变得难以维护和阅读

The solution presented here avoids that by splitting the individual states into their own classes.
 这里的解决方案是将每个状态抽取出来定义成一个类

It might look a little weird, but each state is implemented by a class with static methods, each of which take an instance of Connection as the first argument.
这里看上去有点奇怪，每个状态对象都只有静态方法，并没有存储任何的实例属性数据

This design is based on a decision to not store any instance data in the different state classes themselves.
 实际上，所有状态信息都只存储在 Connection 实例中

Instead, all instance data should be stored on the Connection instance.
 在基类中定义的 NotImplementedError 是为了确保子类实现了相应的方法

The grouping of states under a common base class is mostly there to help organize the code and to ensure that the proper methods get implemented.
 这里你或许还想使用8.12小节讲解的抽象基类方式

An alternative implementation technique concerns direct manipulation of the __class__ attribute of instances.
设计模式中有一种模式叫状态模式，这一小节算是一个初步入门

Calling a Method on an Object Given the Name As a String
8.20 通过字符串调用对象方法¶

You have the name of a method that you want to call on an object stored in a string and you want to execute the method.
你有一个字符串形式的方法名称，想通过它调用某个对象的对应方法

For simple cases, you might use getattr(), like this:
最简单的情况，可以使用 getattr() ：

An alternative approach is to use operator.methodcaller().
另外一种方法是使用 operator.methodcaller() ，例如：

operator.methodcaller() may be useful if you want to look up a method by name and supply the same arguments over and over again.
当你需要通过相同的参数多次调用某个方法时，使用 operator.methodcaller 就很方便了

For instance, if you need to sort an entire list of points:
 比如你需要排序一系列的点，就可以这样做：

Calling a method is actually two separate steps involving an attribute lookup and a function call.
调用一个方法实际上是两部独立操作，第一步是查找属性，第二步是函数调用

Therefore, to call a method, you simply look up the attribute using getattr(), as for any other attribute.
 因此，为了调用某个方法，你可以首先通过 getattr() 来查找到这个属性，然后再去以函数方式调用它即可

operator.methodcaller() creates a callable object, but also fixes any arguments that are going to be supplied to the method.
operator.methodcaller() 创建一个可调用对象，并同时提供所有必要参数， 然后调用的时候只需要将实例对象传递给它即可，比如：

Invoking methods using names contained in strings is somewhat common in code that emulates case statements or variants of the visitor pattern.
通过方法名称字符串来调用方法通常出现在需要模拟 case 语句或实现访问者模式的时候

See the next recipe for a more advanced example.
 参考下一小节获取更多高级例子

Implementing the Visitor Pattern
8.21 实现访问者模式¶

You need to write code that processes or navigates through a complicated data structure consisting of many different kinds of objects, each of which needs to be handled in a different way.
你要处理由大量不同类型的对象组成的复杂数据结构，每一个对象都需要需要进行不同的处理

For example, walking through a tree structure and performing different actions depending on what kind of tree nodes are encountered.
 比如，遍历一个树形结构，然后根据每个节点的相应状态执行不同的操作

The problem addressed by this recipe is one that often arises in programs that build data structures consisting of a large number of different kinds of objects.
这里遇到的问题在编程领域中是很普遍的，有时候会构建一个由大量不同对象组成的数据结构

To illustrate, suppose you are trying to write a program that represents mathematical expressions.
 假设你要写一个表示数学表达式的程序，那么你可能需要定义如下的类：

These classes would then be used to build up nested data structures, like this:
然后利用这些类构建嵌套数据结构，如下所示：

The problem is not the creation of such structures, but in writing code that processes them later.
这样做的问题是对于每个表达式，每次都要重新定义一遍，有没有一种更通用的方式让它支持所有的数字和操作符呢

For example, given such an expression, a program might want to do any number of things (e.g., produce output, generate instructions, perform translation, etc.).
 这里我们使用访问者模式可以达到这样的目的：

To use this class, a programmer inherits from it and implements various methods of the form visit_Name(), where Name is substituted with the node type.
为了使用这个类，可以定义一个类继承它并且实现各种 visit_Name() 方法，其中Name是node类型

For example, if you want to evaluate the expression, you could write this: Here is an example of how you would use this class using the previously generated expression:
 例如，如果你想求表达式的值，可以这样写：

As a completely different example, here is a class that translates an expression into operations on a simple stack machine:
作为一个不同的例子，下面定义一个类在一个栈上面将一个表达式转换成多个操作序列：

It should be noted that this particular technique of dispatching to a method is also a common way to emulate the behavior of switch or case statements from other languages.
还有一点需要指出的是，这种技术也是实现其他语言中switch或case语句的方式

For example, if you are writing an HTTP framework, you might have classes that do a similar kind of dispatch:
 比如，如果你正在写一个HTTP框架，你可能会写这样一个请求分发的控制器：

One weakness of the visitor pattern is its heavy reliance on recursion.
访问者模式一个缺点就是它严重依赖递归，如果数据结构嵌套层次太深可能会有问题， 有时候会超过Python的递归深度限制(参考 sys.getrecursionlimit() )

If you try to apply it to a deeply nested structure, it’s possible that you will hit Python’s recursion depth limit (see sys.getrecursionlimit()).
 

Use of the visitor pattern is extremely common in programs related to parsing and compiling.
在跟解析和编译相关的编程中使用访问者模式是非常常见的

One notable implementation can be found in Python’s own ast module.
 Python本身的 ast 模块值的关注下，可以去看看源码

In addition to allowing traversal of tree structures, it provides a variation that allows a data structure to be rewritten or transformed as it is traversed (e.g., nodes added or removed).
 9.24小节演示了一个利用 ast 模块来处理Python源代码的例子

Implementing the Visitor Pattern Without Recursion
8.22 不用递归实现访问者模式¶

You’re writing code that navigates through a deeply nested tree structure using the visitor pattern, but it blows up due to exceeding the recursion limit.
你使用访问者模式遍历一个很深的嵌套树形数据结构，并且因为超过嵌套层级限制而失败

You’d like to eliminate the recursion, but keep the programming style of the visitor pattern.
 你想消除递归，并同时保持访问者编程模式

Clever use of generators can sometimes be used to eliminate recursion from algorithms involving tree traversal or searching.
通过巧妙的使用生成器可以在树遍历或搜索算法中消除递归

In “Implementing the Visitor Pattern”, a visitor class was presented.
 在8.21小节中，我们给出了一个访问者类

Here is an alternative implementation of that class that drives the computation in an entirely different way using a stack and generators:
 下面我们利用一个栈和生成器重新实现这个类：

If you use this class, you’ll find that it still works with existing code that might have used recursion.
如果你使用这个类，也能达到相同的效果

In fact, you can use it as a drop-in replacement for the visitor implementation in the prior recipe.
事实上你完全可以将它作为上一节中的访问者模式的替代实现

For example, consider the following code, which involves expression trees:
 考虑如下代码，遍历一个表达式的树：

The preceding code works for simple expressions.
如果嵌套层次太深那么上述的Evaluator就会失效：

Now let’s change the Evaluator class ever so slightly to the following:
现在我们稍微修改下上面的Evaluator：

If you try the same recursive experiment, you’ll find that it suddenly works.
再次运行，就不会报错了：

If you want to add custom processing into any of the methods, it still works.
如果你还想添加其他自定义逻辑也没问题：

Here is some sample output:
下面是简单的测试：

This recipe nicely illustrates how generators and coroutines can perform mind-bending tricks involving program control flow, often to great advantage.
这一小节我们演示了生成器和协程在程序控制流方面的强大功能

To understand this recipe, a few key insights are required.
 避免递归的一个通常方法是使用一个栈或队列的数据结构

The second insight concerns the behavior of the yield statement in generators.
另外一个需要理解的就是生成器中yield语句

When yield is encountered, the behavior of a generator is to emit a value and to suspend.
当碰到yield语句时，生成器会返回一个数据并暂时挂起

This recipe uses this as a replacement for recursion.
 上面的例子使用这个技术来代替了递归

For example, instead of writing a recursive expression like this:
例如，之前我们是这样写递归：

you replace it with the following:
现在换成yield语句：

Behind the scenes, this sends the node in question (node.left) back to the visit() method.
它会将 node.left 返回给 visit() 方法，然后 visit() 方法调用那个节点相应的 visit_Name() 方法

The visit() method then carries out the execution of the appropriate visit_Name() method for that node.
 yield暂时将程序控制器让出给调用者，当执行完后，结果会赋值给value，

The final part of this recipe concerns propagation of results.
看完这一小节，你也许想去寻找其它没有yield语句的方案

When generator functions are used, you can no longer use return statements to emit values (doing so will cause a SyntaxError exception).
但是这么做没有必要，你必须处理很多棘手的问题

Thus, the yield statement has to do double duty to cover the case.
 例如，为了消除递归，你必须要维护一个栈结构，如果不使用生成器，代码会变得很臃肿，到处都是栈操作语句、回调函数等

In this recipe, if the value produced by a yield statement is a non-Node type, it is assumed to be a value that will be propagated to the next step of the calculation.
 实际上，使用yield语句可以让你写出非常漂亮的代码，它消除了递归但是看上去又很像递归实现，代码很简洁

Managing Memory in Cyclic Data Structures
8.23 循环引用数据结构的内存管理¶

Your program creates data structures with cycles (e.g., trees, graphs, observer patterns, etc.), but you are experiencing problems with memory management.
你的程序创建了很多循环引用数据结构(比如树、图、观察者模式等)，你碰到了内存管理难题

A simple example of a cyclic data structure is a tree structure where a parent points to its children and the children point back to their parent.
一个简单的循环引用数据结构例子就是一个树形结构，双亲节点有指针指向孩子节点，孩子节点又返回来指向双亲节点

For code like this, you should consider making one of the links a weak reference using the weakref library.
 这种情况下，可以考虑使用 weakref 库中的弱引用

For example:
例如：

This implementation allows the parent to quietly die.
这种是想方式允许parent静默终止

For example:
例如：

Cyclic data structures are a somewhat tricky aspect of Python that require careful study because the usual rules of garbage collection often don’t apply.
循环引用的数据结构在Python中是一个很棘手的问题，因为正常的垃圾回收机制不能适用于这种情形

For example, consider this code:
 例如考虑如下代码：

Now, using this code, try some experiments to see some subtle issues with garbage collection:
下面我们使用这个代码来做一些垃圾回收试验：

As you can see, objects are deleted immediately all except for the last case involving a cycle.
可以看到，最后一个的删除时打印语句没有出现

The reason is that Python’s garbage collection is based on simple reference counting.
原因是Python的垃圾回收机制是基于简单的引用计数

When the reference count of an object reaches 0, it is immediately deleted.
 当一个对象的引用数变成0的时候才会立即删除掉

For cyclic data structures, however, this never happens.
而对于循环引用这个条件永远不会成立

Thus, in the last part of the example, the parent and child nodes refer to each other, keeping the reference count nonzero.
 因此，在上面例子中最后部分，父节点和孩子节点互相拥有对方的引用，导致每个对象的引用计数都不可能变成0

To deal with cycles, there is a separate garbage collector that runs periodically.
Python有另外的垃圾回收器来专门针对循环引用的，但是你永远不知道它什么时候会触发

However, as a general rule, you never know when it might run.
 另外你还可以手动的触发它，但是代码看上去很挫：

An even worse problem occurs if the objects involved in a cycle define their own __del__() method.
如果循环引用的对象自己还定义了自己的 __del__() 方法，那么会让情况变得更糟糕

For example, suppose the code looked like this:
 假设你像下面这样给Node定义自己的 __del__() 方法：

In this case, the data structures will never be garbage collected at all and your program will leak memory!
这种情况下，垃圾回收永远都不会去回收这个对象的，还会导致内存泄露

If you try it, you’ll see that the Data.__del__ message never appears at all—even after a forced garbage collection:
 如果你试着去运行它会发现，Data.__del__ 消息永远不会出现了,甚至在你强制内存回收时：

Weak references solve this problem by eliminating reference cycles.
弱引用消除了引用循环的这个问题，本质来讲，弱引用就是一个对象指针，它不会增加它的引用计数

Essentially, a weak reference is a pointer to an object that does not increase its reference count.
 你可以通过 weakref 来创建弱引用

You create weak references using the weakref library.
例如：

To dereference a weak reference, you call it like a function.
为了访问弱引用所引用的对象，你可以像函数一样去调用它即可

If the referenced object still exists, it is returned.
如果那个对象还存在就会返回它，否则就返回一个None

Otherwise, None is returned.
 由于原始对象的引用计数没有增加，那么就可以去删除它了

Since the reference count of the original object wasn’t increased, it can be deleted normally.
例如;

By using weak references, as shown in the solution, you’ll find that there are no longer any reference cycles and that garbage collection occurs immediately once a node is no longer being used.
通过这里演示的弱引用技术，你会发现不再有循环引用问题了，一旦某个节点不被使用了，垃圾回收器立即回收它

See “Creating Cached Instances” for another example involving weak references.
 你还能参考8.25小节关于弱引用的另外一个例子

Making Classes Support Comparison Operations
8.24 让类支持比较操作¶

You’d like to be able to compare instances of your class using the standard comparison operators (e.g., >=, !=, <=, etc.), but without having to write a lot of special methods.
你想让某个类的实例支持标准的比较运算(比如>=,!=,<=,<等)，但是又不想去实现那一大丢的特殊方法

Python classes can support comparison by implementing a special method for each comparison operator.
Python类对每个比较操作都需要实现一个特殊方法来支持

For example, to support the >= operator, you define a __ge__() method in the classes.
 例如为了支持>=操作符，你需要定义一个 __ge__() 方法

Although defining a single method is usually no problem, it quickly gets tedious to create implementations of every possible comparison operator.
 尽管定义一个方法没什么问题，但如果要你实现所有可能的比较方法那就有点烦人了

The functools.total_ordering decorator can be used to simplify this process.
装饰器 functools.total_ordering 就是用来简化这个处理的

To use it, you decorate a class with it, and define __eq__() and one other comparison method (__lt__, __le__, __gt__, or __ge__).
 使用它来装饰一个来，你只需定义一个 __eq__() 方法， 外加其他方法(__lt__, __le__, __gt__, or __ge__)中的一个即可

The decorator then fills in the other comparison methods for you.
 然后装饰器会自动为你填充其它比较方法

As an example, let’s build some houses and add some rooms to them, and then perform comparisons based on the size of the houses:
作为例子，我们构建一些房子，然后给它们增加一些房间，最后通过房子大小来比较它们：

Here, the House class has been decorated with @total_ordering.
这里我们只是给House类定义了两个方法：__eq__() 和 __lt__() ，它就能支持所有的比较操作：

If you’ve written the code to make a class support all of the basic comparison operators, then total_ordering probably doesn’t seem all that magical: it literally defines a mapping from each of the comparison-supporting methods to all of the other ones that would be required.
其实 total_ordering 装饰器也没那么神秘

So, if you defined __lt__() in your class as in the solution, it is used to build all of the other comparison operators.
 它就是定义了一个从每个比较支持方法到所有需要定义的其他方法的一个映射而已

It’s really just filling in the class with methods like this:
 比如你定义了 __le__() 方法，那么它就被用来构建所有其他的需要定义的那些特殊方法

Sure, it’s not hard to write these methods yourself, but @total_ordering simply takes the guesswork out of it.
当然，你自己去写也很容易，但是使用 @total_ordering 可以简化代码，何乐而不为呢

Creating Cached Instances
8.25 创建缓存实例¶

When creating instances of a class, you want to return a cached reference to a previous instance created with the same arguments (if any).
在创建一个类的对象时，如果之前使用同样参数创建过这个对象， 你想返回它的缓存引用

The problem being addressed in this recipe sometimes arises when you want to ensure that there is only one instance of a class created for a set of input arguments.
这种通常是因为你希望相同参数创建的对象时单例的

Practical examples include the behavior of libraries, such as the logging module, that only want to associate a single logger instance with a given name.
 在很多库中都有实际的例子，比如 logging 模块，使用相同的名称创建的 logger 实例永远只有一个

For example:
例如：

To implement this behavior, you should make use of a factory function that’s separate from the class itself.
为了达到这样的效果，你需要使用一个和类本身分开的工厂函数，例如：

If you use this implementation, you’ll find that it behaves in the manner shown earlier:
然后做一个测试，你会发现跟之前那个日志对象的创建行为是一致的：

Writing a special factory function is often a simple approach for altering the normal rules of instance creation.
编写一个工厂函数来修改普通的实例创建行为通常是一个比较简单的方法

One question that often arises at this point is whether or not a more elegant approach could be taken.
 但是我们还能否找到更优雅的解决方案呢

For example, you might consider a solution that redefines the __new__() method of a class as follows:
例如，你可能会考虑重新定义类的 __new__() 方法，就像下面这样：

At first glance, it seems like this code might do the job.
初看起来好像可以达到预期效果，但是问题是 __init__() 每次都会被调用，不管这个实例是否被缓存了

However, a major problem is that the __init__() method always gets called, regardless of whether the instance was cached or not.
例如：

That behavior is probably not what you want.
这个或许不是你想要的效果，因此这种方法并不可取

The use of weak references in this recipe serves an important purpose related to garbage collection, as described in “Managing Memory in Cyclic Data Structures”.
上面我们使用到了弱引用计数，对于垃圾回收来讲是很有帮助的，关于这个我们在8.23小节已经讲过了

When maintaining a cache of instances, you often only want to keep items in the cache as long as they’re actually being used somewhere in the program.
 当我们保持实例缓存时，你可能只想在程序中使用到它们时才保存

A WeakValueDictionary instance only holds onto the referenced items as long as they exist somewhere else.
 一个 WeakValueDictionary 实例只会保存那些在其它地方还在被使用的实例

Otherwise, the dictionary keys disappear when instances are no longer being used.
 否则的话，只要实例不再被使用了，它就从字典中被移除了

Observe:
观察下下面的测试结果：

For many programs, the bare-bones code shown in this recipe will often suffice.
对于大部分程序而已，这里代码已经够用了

However, there are a number of more advanced implementation techniques that can be considered.
不过还是有一些更高级的实现值得了解下

One immediate concern with this recipe might be its reliance on global variables and a factory function that’s decoupled from the original class definition.
首先是这里使用到了一个全局变量，并且工厂函数跟类放在一块

One way to clean this up is to put the caching code into a separate manager class and glue things together like this:
我们可以通过将缓存代码放到一个单独的缓存管理器中：

One feature of this approach is that it affords a greater degree of potential flexibility.
这样的话代码更清晰，并且也更灵活，我们可以增加更多的缓存管理机制，只需要替代manager即可

Another design consideration is whether or not you want to leave the class definition exposed to the user.
还有一点就是，我们暴露了类的实例化给用户，用户很容易去直接实例化这个类，而不是使用工厂方法，如：

Alternatively, if you want to give users a stronger hint that they shouldn’t instantiate Spam instances directly, you can make __init__() raise an exception and use a class method to make an alternate constructor like this:
有几种方式可以防止用户这样做，第一个是将类的名字修改为以下划线(_)开头，提示用户别直接调用它

To use this, you modify the caching code to use Spam._new() to create instances instead of the usual call to Spam().
然后修改缓存管理器代码，使用 Spam._new() 来创建实例，而不是直接调用 Spam() 构造函数：

Although there are more extreme measures that can be taken to hide the visibility of the Spam class, it’s probably best to not overthink the problem.
最后这样的方案就已经足够好了

Using an underscore on the name or defining a class method constructor is usually enough for programmers to get a hint.
 缓存和其他构造模式还可以使用9.13小节中的元类实现的更优雅一点(使用了更高级的技术)

