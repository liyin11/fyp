Chapter 1. Data Structures and Algorithms
第一章：数据结构和算法¶

Python provides a variety of useful built-in data structures, such as lists, sets, and dictionaries.
Python提供了大量的内置数据结构，包括列表，集合以及字典

For the most part, the use of these structures is straightforward.
大多数情况下使用这些数据结构是很简单的

However, common questions concerning searching, sorting, ordering, and filtering often arise.
 但是，我们也会经常碰到到诸如查询，排序和过滤等等这些普遍存在的问题

Thus, the goal of this chapter is to discuss common data structures and algorithms involving data.
 因此，这一章的目的就是讨论这些比较常见的问题和算法

In addition, treatment is given to the various data structures contained in the collections module.
 另外，我们也会给出在集合模块 collections 当中操作这些数据结构的方法

Unpacking a Sequence into Separate Variables
1.1 解压序列赋值给多个变量¶

You have an N-element tuple or sequence that you would like to unpack into a collection of N variables.
现在有一个包含N个元素的元组或者是序列，怎样将它里面的值解压后同时赋值给N个变量

Any sequence (or iterable) can be unpacked into variables using a simple assignment operation.
任何的序列(或者是可迭代对象)可以通过一个简单的赋值语句解压并赋值给多个变量

The only requirement is that the number of variables and structure match the sequence.
 唯一的前提就是变量的数量必须跟序列元素的数量是一样的

If there is a mismatch in the number of elements, you’ll get an error.
如果变量个数和序列元素的个数不匹配，会产生一个异常

Unpacking actually works with any object that happens to be iterable, not just tuples or lists.
实际上，这种解压赋值可以用在任何可迭代对象上面，而不仅仅是列表或者元组

This includes strings, files, iterators, and generators.
 包括字符串，文件对象，迭代器和生成器

When unpacking, you may sometimes want to discard certain values.
有时候，你可能只想解压一部分，丢弃其他的值

Python has no special syntax for this, but you can often just pick a throwaway variable name for it.
对于这种情况Python并没有提供特殊的语法

For example:
 但是你可以使用任意变量名去占位，到时候丢掉这些变量就行了

However, make sure that the variable name you pick isn’t being used for something else already.
你必须保证你选用的那些占位变量名在其他地方没被使用到

Unpacking Elements from Iterables of Arbitrary Length
1.2 解压可迭代对象赋值给多个变量¶

You need to unpack N elements from an iterable, but the iterable may be longer than N elements, causing a "too many values to unpack" exception.
如果一个可迭代对象的元素个数超过变量个数时，会抛出一个 ValueError 

Python "star expressions" can be used to address this problem.
Python的星号表达式可以用来解决这个问题

For example, suppose you run a course and decide at the end of the semester that you’re going to drop the first and last homework grades, and only average the rest of them.
比如，你在学习一门课程，在学期末的时候， 你想统计下家庭作业的平均成绩，但是排除掉第一个和最后一个分数

If there are only four assignments, maybe you simply unpack all four, but what if there are 24?
如果只有四个分数，你可能就直接去简单的手动赋值， 但如果有24个呢

A star expression makes it easy:
这时候星号表达式就派上用场了：

As another use case, suppose you have user records that consist of a name and email address, followed by an arbitrary number of phone numbers.
另外一种情况，假设你现在有一些用户的记录列表，每条记录包含一个名字、邮件，接着就是不确定数量的电话号码

You could unpack the records like this:
 你可以像下面这样分解这些记录：

It’s worth noting that the phone_numbers variable will always be a list, regardless of how many phone numbers are unpacked (including none).
值得注意的是上面解压出的 phone_numbers 变量永远都是列表类型，不管解压的电话号码数量是多少(包括0个)

Thus, any code that uses phone_numbers won’t have to account for the possibility that it might not be a list or perform any kind of additional type checking.
 所以，任何使用到 phone_numbers 变量的代码就不需要做多余的类型检查去确认它是否是列表类型了

The starred variable can also be the first one in the list.
星号表达式也能用在列表的开始部分

For example, say you have a sequence of values representing your company’s sales figures for the last eight quarters.
比如，你有一个公司前8个月销售数据的序列， 但是你想看下最近一个月数据和前面7个月的平均值的对比

If you want to see how the most recent quarter stacks up to the average of the first seven, you could do something like this:
你可以这样做：

Here’s a view of the operation from the Python interpreter:
下面是在Python解释器中执行的结果：

Extended iterable unpacking is tailor-made for unpacking iterables of unknown or arbitrary length.
扩展的迭代解压语法是专门为解压不确定个数或任意个数元素的可迭代对象而设计的

Oftentimes, these iterables have some known component or pattern in their construction (e.g.
 通常，这些可迭代对象的元素结构有确定的规则（比如第1个元素后面都是电话号码）， 星号表达式让开发人员可以很容易的利用这些规则来解压出元素来

"everything after element 1 is a phone number"), and star unpacking lets the developer leverage those patterns easily instead of performing acrobatics to get at the relevant elements in the iterable.
 而不是通过一些比较复杂的手段去获取这些关联的的元素值

It is worth noting that the star syntax can be especially useful when iterating over a sequence of tuples of varying length.
值得注意的是，星号表达式在迭代元素为可变长元组的序列时是很有用的

For example, perhaps a sequence of tagged tuples:
 比如，下面是一个带有标签的元组序列：

Star unpacking can also be useful when combined with certain kinds of string processing operations, such as splitting.
星号解压语法在字符串操作的时候也会很有用，比如字符串的分割

Sometimes you might want to unpack values and throw them away.
有时候，你想解压一些元素后丢弃它们，你不能简单就使用 * ， 但是你可以使用一个普通的废弃名称，比如 _ 或者 ign 

There is a certain similarity between star unpacking and list-processing features of various functional languages.
在很多函数式语言中，星号解压语法跟列表处理有许多相似之处

For example, if you have a list, you can easily split it into head and tail components like this:
比如，如果你有一个列表， 你可以很容易的将它分割成前后两部分：

One could imagine writing functions that perform such splitting in order to carry out some kind of clever recursive algorithm.
如果你够聪明的话，还能用这种分割语法去巧妙的实现递归算法

For example:
比如：

However, be aware that recursion really isn’t a strong Python feature due to the inherent recursion limit.
然后，由于语言层面的限制，递归并不是Python擅长的

Thus, this last example might be nothing more than an academic curiosity in practice.
 因此，最后那个递归演示仅仅是个好奇的探索罢了，对这个不要太认真了

Keeping the Last N Items
1.3 保留最后N个元素¶

You want to keep a limited history of the last few items seen during iteration or during some other kind of processing.
在迭代操作或者其他操作的时候，怎样只保留最后有限几个元素的历史记录

Keeping a limited history is a perfect use for a collections.deque.
保留有限历史记录正是 collections.deque 大显身手的时候

For example, the following code performs a simple text match on a sequence of lines and yields the matching line along with the previous N lines of context when found:
比如，下面的代码在多行上面做简单的文本匹配， 并返回匹配所在行的最后N行：

When writing code to search for items, it is common to use a generator function involving yield, as shown in this recipe’s solution.
我们在写查询元素的代码时，通常会使用包含 yield 表达式的生成器函数，也就是我们上面示例代码中的那样

This decouples the process of searching from the code that uses the results.
 这样可以将搜索过程代码和使用搜索结果代码解耦

If you’re new to generators, see “Creating New Iteration Patterns with Generators”.
如果你还不清楚什么是生成器，请参看4.3节

Using deque(maxlen=N) creates a fixed-sized queue.
使用 deque(maxlen=N) 构造函数会新建一个固定大小的队列

When new items are added and the queue is full, the oldest item is automatically removed.
当新的元素加入并且这个队列已满的时候， 最老的元素会自动被移除掉

Although you could manually perform such operations on a list (e.g., appending, deleting, etc.), the queue solution is far more elegant and runs a lot faster.
尽管你也可以手动在一个列表上实现这一的操作(比如增加、删除等等)

More generally, a deque can be used whenever you need a simple queue structure.
更一般的， deque 类可以被用在任何你只需要一个简单队列数据结构的场合

If you don’t give it a maximum size, you get an unbounded queue that lets you append and pop items on either end.
 如果你不设置最大队列大小，那么就会得到一个无限大小队列，你可以在队列的两端执行添加和弹出元素的操作

Adding or popping items from either end of a queue has O(1) complexity.
在队列两端插入或删除元素时间复杂度都是 O(1) ，而在列表的开头插入或删除元素的时间复杂度为 O(N) 

Finding the Largest or Smallest N Items
1.4 查找最大或最小的N个元素¶

You want to make a list of the largest or smallest N items in a collection.
怎样从一个集合中获得最大或者最小的N个元素列表

The heapq module has two functions—nlargest() and nsmallest()—that do exactly what you want.
heapq模块有两个函数：nlargest() 和 nsmallest() 可以完美解决这个问题

Both functions also accept a key parameter that allows them to be used with more complicated data structures.
两个函数都能接受一个关键字参数，用于更复杂的数据结构中：

If you are looking for the N smallest or largest items and N is small compared to the overall size of the collection, these functions provide superior performance.
如果你想在一个集合中查找最小或最大的N个元素，并且N小于集合元素数量，那么这些函数提供了很好的性能

Underneath the covers, they work by first converting the data into a list where items are ordered as a heap.
 因为在底层实现里面，首先会先将集合数据进行堆排序后放入一个列表中：

The most important feature of a heap is that heap[0] is always the smallest item.
堆数据结构最重要的特征是 heap[0] 永远是最小的元素

Moreover, subsequent items can be easily found using the heapq.heappop() method, which pops off the first item and replaces it with the next smallest item (an operation that requires O(log N) operations where N is the size of the heap).
并且剩余的元素可以很容易的通过调用 heapq.heappop() 方法得到， 该方法会先将第一个元素弹出来，然后用下一个最小的元素来取代被弹出元素(这种操作时间复杂度仅仅是O(log N)，N是堆大小)

For example, to find the three smallest items, you would do this:
 比如，如果想要查找最小的3个元素，你可以这样做：

The nlargest() and nsmallest() functions are most appropriate if you are trying to find a relatively small number of items.
当要查找的元素个数相对比较小的时候，函数 nlargest() 和 nsmallest() 是很合适的

If you are simply trying to find the single smallest or largest item (N=1), it is faster to use min() and max().
 如果你仅仅想查找唯一的最小或最大(N=1)的元素的话，那么使用 min() 和 max() 函数会更快些

Similarly, if N is about the same size as the collection itself, it is usually faster to sort it first and take a slice (i.e., use sorted(items)[:N] or sorted(items)[-N:]).
 类似的，如果N的大小和集合大小接近的时候，通常先排序这个集合然后再使用切片操作会更快点 ( sorted(items)[:N] 或者是 sorted(items)[-N:] )

It should be noted that the actual implementation of nlargest() and nsmallest() is adaptive in how it operates and will carry out some of these optimizations on your behalf (e.g., using sorting if N is close to the same size as the input).
 需要在正确场合使用函数 nlargest() 和 nsmallest() 才能发挥它们的优势 (如果N快接近集合大小了，那么使用排序操作会更好些)

Although it’s not necessary to use this recipe, the implementation of a heap is an interesting and worthwhile subject of study.
尽管你没有必要一定使用这里的方法，但是堆数据结构的实现是一个很有趣并且值得你深入学习的东西

This can usually be found in any decent book on algorithms and data structures.
 基本上只要是数据结构和算法书籍里面都会有提及到

The documentation for the heapq module also discusses the underlying implementation details.
 heapq 模块的官方文档里面也详细的介绍了堆数据结构底层的实现细节

Implementing a Priority Queue
1.5 实现一个优先级队列¶

You want to implement a queue that sorts items by a given priority and always returns the item with the highest priority on each pop operation.
怎样实现一个按优先级排序的队列

The following class uses the heapq module to implement a simple priority queue:
下面的类利用 heapq 模块实现了一个简单的优先级队列：

Here is an example of how it might be used:
下面是它的使用方式：

Observe how the first pop() operation returned the item with the highest priority.
仔细观察可以发现，第一个 pop() 操作返回优先级最高的元素

Also observe how the two items with the same priority (foo and grok) were returned in the same order in which they were inserted into the queue.
 另外注意到如果两个有着相同优先级的元素( foo 和 grok )，pop操作按照它们被插入到队列的顺序返回的

The core of this recipe concerns the use of the heapq module.
这一小节我们主要关注 heapq 模块的使用

The functions heapq.heappush() and heapq.heappop() insert and remove items from a list _queue in a way such that the first item in the list has the smallest priority (as discussed in “Finding the Largest or Smallest N Items”).
 函数 heapq.heappush() 和 heapq.heappop() 分别在队列 _queue 上插入和删除第一个元素， 并且队列_queue保证第一个元素拥有最小优先级(1.4节已经讨论过这个问题)

The heappop() method always returns the "smallest" item, so that is the key to making the queue pop the correct items.
 heappop() 函数总是返回”最小的”的元素，这就是保证队列pop操作返回正确元素的关键

Moreover, since the push and pop operations have O(log N) complexity where N is the number of items in the heap, they are fairly efficient even for fairly large values of N.
 另外，由于push和pop操作时间复杂度为O(log N)，其中N是堆的大小，因此就算是N很大的时候它们运行速度也依旧很快

In this recipe, the queue consists of tuples of the form (-priority, index, item).
在上面代码中，队列包含了一个 (-priority, index, item) 的元组

The priority value is negated to get the queue to sort items from highest priority to lowest priority.
 优先级为负数的目的是使得元素按照优先级从高到低排序

This is opposite of the normal heap ordering, which sorts from lowest to highest value.
 这个跟普通的按优先级从低到高排序的堆排序恰巧相反

The role of the index variable is to properly order items with the same priority level.
index 变量的作用是保证同等优先级元素的正确排序

By keeping a constantly increasing index, the items will be sorted according to the order in which they were inserted.
 通过保存一个不断增加的 index 下标变量，可以确保元素按照它们插入的顺序排序

However, the index also serves an important role in making the comparison operations work for items that have the same priority level.
 而且， index 变量也在相同优先级元素比较的时候起到重要作用

To elaborate on that, instances of Item in the example can’t be ordered.
为了阐明这些，先假定Item实例是不支持排序的：

If you make (priority, item) tuples, they can be compared as long as the priorities are different.
如果你使用元组 (priority, item) ，只要两个元素的优先级不同就能比较

However, if two tuples with equal priorities are compared, the comparison fails as before.
 但是如果两个元素优先级一样的话，那么比较操作就会跟之前一样出错：

By introducing the extra index and making (priority, index, item) tuples, you avoid this problem entirely since no two tuples will ever have the same value for index (and Python never bothers to compare the remaining tuple values once the result of comparison can be determined):
通过引入另外的 index 变量组成三元组 (priority, index, item) ，就能很好的避免上面的错误， 因为不可能有两个元素有相同的 index 值

If you want to use this queue for communication between threads, you need to add appropriate locking and signaling.
如果你想在多个线程中使用同一个队列，那么你需要增加适当的锁和信号量机制

See “Communicating Between Threads” for an example of how to do this.
 可以查看12.3小节的例子演示是怎样做的

The documentation for the heapq module has further examples and discussion concerning the theory and implementation of heaps.
heapq 模块的官方文档有更详细的例子程序以及对于堆理论及其实现的详细说明

Mapping Keys to Multiple Values in a Dictionary
1.6 字典中的键映射多个值¶

You want to make a dictionary that maps keys to more than one value (a so-called "multidict").
怎样实现一个键对应多个值的字典(也叫 multidict )

A dictionary is a mapping where each key is mapped to a single value.
一个字典就是一个键对应一个单值的映射

If you want to map keys to multiple values, you need to store the multiple values in another container such as a list or set.
如果你想要一个键映射多个值，那么你就需要将这多个值放到另外的容器中， 比如列表或者集合里面

For example, you might make dictionaries like this:
比如，你可以像下面这样构造这样的字典：

The choice of whether or not to use lists or sets depends on intended use.
选择使用列表还是集合取决于你的实际需求

Use a list if you want to preserve the insertion order of the items.
如果你想保持元素的插入顺序就应该使用列表， 如果想去掉重复元素就使用集合（并且不关心元素的顺序问题）

To easily construct such dictionaries, you can use defaultdict in the collections module.
你可以很方便的使用 collections 模块中的 defaultdict 来构造这样的字典

A feature of defaultdict is that it automatically initializes the first value so you can simply focus on adding items.
 defaultdict 的一个特征是它会自动初始化每个 key 刚开始对应的值，所以你只需要关注添加元素操作了

For example:
比如：

One caution with defaultdict is that it will automatically create dictionary entries for keys accessed later on (even if they aren’t currently found in the dictionary).
需要注意的是， defaultdict 会自动为将要访问的键(就算目前字典中并不存在这样的键)创建映射实体

If you don’t want this behavior, you might use setdefault() on an ordinary dictionary instead.
 如果你并不需要这样的特性，你可以在一个普通的字典上使用 setdefault() 方法来代替

For example:
比如：

However, many programmers find setdefault() to be a little unnatural—not to mention the fact that it always creates a new instance of the initial value on each invocation (the empty list [] in the example).
但是很多程序员觉得 setdefault() 用起来有点别扭

In principle, constructing a multivalued dictionary is simple.
一般来讲，创建一个多值映射字典是很简单的

However, initialization of the first value can be messy if you try to do it yourself.
但是，如果你选择自己实现的话，那么对于值的初始化可能会有点麻烦， 你可能会像下面这样来实现：

Using a defaultdict simply leads to much cleaner code:
如果使用 defaultdict 的话代码就更加简洁了：

This recipe is strongly related to the problem of grouping records together in data processing problems.
这一小节所讨论的问题跟数据处理中的记录归类问题有大的关联

See “Grouping Records Together Based on a Field” for an example.
可以参考1.15小节的例子

Keeping Dictionaries in Order
1.7 字典排序¶

You want to create a dictionary, and you also want to control the order of items when iterating or serializing.
你想创建一个字典，并且在迭代或序列化这个字典的时候能够控制元素的顺序

To control the order of items in a dictionary, you can use an OrderedDict from the collections module.
为了能控制一个字典中元素的顺序，你可以使用 collections 模块中的 OrderedDict 类

It exactly preserves the original insertion order of data when iterating.
 在迭代操作的时候它会保持元素被插入时的顺序，示例如下：

An OrderedDict can be particularly useful when you want to build a mapping that you may want to later serialize or encode into a different format.
当你想要构建一个将来需要序列化或编码成其他格式的映射的时候， OrderedDict 是非常有用的

For example, if you want to precisely control the order of fields appearing in a JSON encoding, first building the data in an OrderedDict will do the trick:
 比如，你想精确控制以JSON编码后字段的顺序，你可以先使用 OrderedDict 来构建这样的数据：

An OrderedDict internally maintains a doubly linked list that orders the keys according to insertion order.
OrderedDict 内部维护着一个根据键插入顺序排序的双向链表

When a new item is first inserted, it is placed at the end of this list.
每次当一个新的元素插入进来的时候， 它会被放到链表的尾部

Subsequent reassignment of an existing key doesn’t change the order.
对于一个已经存在的键的重复赋值不会改变键的顺序

Be aware that the size of an OrderedDict is more than twice as large as a normal dictionary due to the extra linked list that’s created.
需要注意的是，一个 OrderedDict 的大小是一个普通字典的两倍，因为它内部维护着另外一个链表

Thus, if you are going to build a data structure involving a large number of OrderedDict instances (e.g., reading 100,000 lines of a CSV file into a list of OrderedDict instances), you would need to study the requirements of your application to determine if the benefits of using an OrderedDict outweighed the extra memory overhead.
 所以如果你要构建一个需要大量 OrderedDict 实例的数据结构的时候(比如读取100,000行CSV数据到一个 OrderedDict 列表中去)， 那么你就得仔细权衡一下是否使用 OrderedDict 带来的好处要大过额外内存消耗的影响

Calculating with Dictionaries
1.8 字典的运算¶

You want to perform various calculations (e.g., minimum value, maximum value, sorting, etc.) on a dictionary of data.
怎样在数据字典中执行一些计算操作(比如求最小值、最大值、排序等等)

Consider a dictionary that maps stock names to prices:
考虑下面的股票名和价格映射字典：

In order to perform useful calculations on the dictionary contents, it is often useful to invert the keys and values of the dictionary using zip().
为了对字典值执行计算操作，通常需要使用 zip() 函数先将键和值反转过来

For example, here is how to find the minimum and maximum price and stock name:
 比如，下面是查找最小和最大股票价格和股票值的代码：

Similarly, to rank the data, use zip() with sorted(), as in the following:
类似的，可以使用 zip() 和 sorted() 函数来排列字典数据：

When doing these calculations, be aware that zip() creates an iterator that can only be consumed once.
执行这些计算的时候，需要注意的是 zip() 函数创建的是一个只能访问一次的迭代器

For example, the following code is an error:
 比如，下面的代码就会产生错误：

If you try to perform common data reductions on a dictionary, you’ll find that they only process the keys, not the values.
如果你在一个字典上执行普通的数学运算，你会发现它们仅仅作用于键，而不是值

For example:
比如：

This is probably not what you want because you’re actually trying to perform a calculation involving the dictionary values.
这个结果并不是你想要的，因为你想要在字典的值集合上执行这些计算

You might try to fix this using the values() method of a dictionary:
 或许你会尝试着使用字典的 values() 方法来解决这个问题：

Unfortunately, this is often not exactly what you want either.
不幸的是，通常这个结果同样也不是你想要的

For example, you may want to know information about the corresponding keys (e.g., which stock has the lowest price?).
 你可能还想要知道对应的键的信息(比如那种股票价格是最低的

You can get the key corresponding to the min or max value if you supply a key function to min() and max().
你可以在 min() 和 max() 函数中提供 key 函数参数来获取最小值或最大值对应的键的信息

For example:
比如：

However, to get the minimum value, you’ll need to perform an extra lookup step.
但是，如果还想要得到最小值，你又得执行一次查找操作

For example:
比如：

The solution involving zip() solves the problem by "inverting" the dictionary into a sequence of (value, key) pairs.
前面的 zip() 函数方案通过将字典”反转”为(值，键)元组序列来解决了上述问题

When performing comparisons on such tuples, the value element is compared first, followed by the key.
 当比较两个元组的时候，值会先进行比较，然后才是键

This gives you exactly the behavior that you want and allows reductions and sorting to be easily performed on the dictionary contents using a single statement.
 这样的话你就能通过一条简单的语句就能很轻松的实现在字典上的求最值和排序操作了

It should be noted that in calculations involving (value, key) pairs, the key will be used to determine the result in instances where multiple entries happen to have the same value.
需要注意的是在计算操作中使用到了(值，键)对

For instance, in calculations such as min() and max(), the entry with the smallest or largest key will be returned if there happen to be duplicate values.
当多个实体拥有相同的值的时候，键会决定返回结果

For example:
 比如，在执行 min() 和 max() 操作的时候，如果恰巧最小或最大值有重复的，那么拥有最小或最大键的实体会返回：

Finding Commonalities in Two Dictionaries
1.9 查找两字典的相同点¶

You have two dictionaries and want to find out what they might have in common (same keys, same values, etc.).
怎样在两个字典中寻寻找相同点(比如相同的键、相同的值等等)

Consider two dictionaries:
考虑下面两个字典：

To find out what the two dictionaries have in common, simply perform common set operations using the keys() or items() methods.
为了寻找两个字典的相同点，可以简单的在两字典的 keys() 或者 items() 方法返回结果上执行集合操作

For example:
比如：

These kinds of operations can also be used to alter or filter dictionary contents.
这些操作也可以用于修改或者过滤字典元素

For example, suppose you want to make a new dictionary with selected keys removed.
 比如，假如你想以现有字典构造一个排除几个指定键的新字典

Here is some sample code using a dictionary comprehension:
 下面利用字典推导来实现这样的需求：

A dictionary is a mapping between a set of keys and values.
一个字典就是一个键集合与值集合的映射关系

The keys() method of a dictionary returns a keys-view object that exposes the keys.
 字典的 keys() 方法返回一个展现键集合的键视图对象

A little-known feature of keys views is that they also support common set operations such as unions, intersections, and differences.
 键视图的一个很少被了解的特性就是它们也支持集合操作，比如集合并、交、差运算

Thus, if you need to perform common set operations with dictionary keys, you can often just use the keys-view objects directly without first converting them into a set.
 所以，如果你想对集合的键执行一些普通的集合操作，可以直接使用键视图对象而不用先将它们转换成一个set

The items() method of a dictionary returns an items-view object consisting of (key, value) pairs.
字典的 items() 方法返回一个包含(键，值)对的元素视图对象

This object supports similar set operations and can be used to perform operations such as finding out which key-value pairs two dictionaries have in common.
 这个对象同样也支持集合操作，并且可以被用来查找两个字典有哪些相同的键值对

Although similar, the values() method of a dictionary does not support the set operations described in this recipe.
尽管字典的 values() 方法也是类似，但是它并不支持这里介绍的集合操作

In part, this is due to the fact that unlike keys, the items contained in a values view aren’t guaranteed to be unique.
 某种程度上是因为值视图不能保证所有的值互不相同，这样会导致某些集合操作会出现问题

This alone makes certain set operations of questionable utility.
 不过，如果你硬要在值上面执行这些集合操作的话，你可以先将值集合转换成set，然后再执行集合运算就行了

Removing Duplicates from a Sequence while Maintaining Order
1.10 删除序列相同元素并保持顺序¶

You want to eliminate the duplicate values in a sequence, but preserve the order of the remaining items.
怎样在一个序列上面保持元素顺序的同时消除重复的值

If the values in the sequence are hashable, the problem can be easily solved using a set and a generator.
如果序列上的值都是 hashable 类型，那么可以很简单的利用集合或者生成器来解决这个问题

For example:
比如：

Here is an example of how to use your function:
下面是使用上述函数的例子：

This only works if the items in the sequence are hashable.
这个方法仅仅在序列中元素为 hashable 的时候才管用

If you are trying to eliminate duplicates in a sequence of unhashable types (such as dicts), you can make a slight change to this recipe, as follows:
 如果你想消除元素不可哈希(比如 dict 类型)的序列中重复元素的话，你需要将上述代码稍微改变一下，就像这样：

Here, the purpose of the key argument is to specify a function that converts sequence items into a hashable type for the purposes of duplicate detection.
这里的key参数指定了一个函数，将序列元素转换成 hashable 类型

Here’s how it works:
下面是它的用法示例：

This latter solution also works nicely if you want to eliminate duplicates based on the value of a single field or attribute or a larger data structure.
如果你想基于单个字段、属性或者某个更大的数据结构来消除重复元素，第二种方案同样可以胜任

If all you want to do is eliminate duplicates, it is often easy enough to make a set.
如果你仅仅就是想消除重复元素，通常可以简单的构造一个集合

For example:
比如：

However, this approach doesn’t preserve any kind of ordering.
然而，这种方法不能维护元素的顺序，生成的结果中的元素位置被打乱

So, the resulting data will be scrambled afterward.
而上面的方法可以避免这种情况

The use of a generator function in this recipe reflects the fact that you might want the function to be extremely general purpose—not necessarily tied directly to list processing.
在本节中我们使用了生成器函数让我们的函数更加通用，不仅仅是局限于列表处理

For example, if you want to read a file, eliminating duplicate lines, you could simply do this:
 比如，如果如果你想读取一个文件，消除重复行，你可以很容易像这样做：

The specification of a key function mimics similar functionality in built-in functions such as sorted(), min(), and max().
上述key函数参数模仿了 sorted() , min() 和 max() 等内置函数的相似功能

For instance, see Recipes and .
 可以参考1.8和1.13小节了解更多

Naming a Slice
1.11 命名切片¶

Your program has become an unreadable mess of hardcoded slice indices and you want to clean it up.
你的程序已经出现一大堆已无法直视的硬编码切片下标，然后你想清理下代码

Suppose you have some code that is pulling specific data fields out of a record string with fixed fields (e.g., from a flat file or similar format):
假定你有一段代码要从一个记录字符串中几个固定位置提取出特定的数据字段(比如文件或类似格式)：

Instead of doing that, why not name the slices like this?
与其那样写，为什么不想这样命名切片呢：

In the latter version, you avoid having a lot of mysterious hardcoded indices, and what you’re doing becomes much clearer.
第二种版本中，你避免了大量无法理解的硬编码下标，使得你的代码更加清晰可读了

As a general rule, writing code with a lot of hardcoded index values leads to a readability and maintenance mess.
一般来讲，代码中如果出现大量的硬编码下标值会使得可读性和可维护性大大降低

For example, if you come back to the code a year later, you’ll look at it and wonder what you were thinking when you wrote it.
 比如，如果你回过来看看一年前你写的代码，你会摸着脑袋想那时候自己到底想干嘛啊

The solution shown is simply a way of more clearly stating what your code is actually doing.
 这里的解决方案是一个很简单的方法让你更加清晰的表达代码到底要做什么

In general, the built-in slice() creates a slice object that can be used anywhere a slice is allowed.
内置的 slice() 函数创建了一个切片对象，可以被用在任何切片允许使用的地方

For example:
比如：

If you have a slice instance s, you can get more information about it by looking at its s.start, s.stop, and s.step attributes, respectively.
如果你有一个切片对象a，你可以分别调用它的 a.start , a.stop , a.step 属性来获取更多的信息

For example:
比如：

In addition, you can map a slice onto a sequence of a specific size by using its indices(size) method.
另外，你还能通过调用切片的 indices(size) 方法将它映射到一个确定大小的序列上， 这个方法返回一个三元组 (start, stop, step) ，所有值都会被合适的缩小以满足边界限制， 从而使用的时候避免出现 IndexError 异常

This returns a tuple (start, stop, step) where all values have been suitably limited to fit within bounds (as to avoid IndexError exceptions when indexing).
比如：

Determining the Most Frequently Occurring Items in a Sequence
1.12 序列中出现次数最多的元素¶

You have a sequence of items, and you’d like to determine the most frequently occurring items in the sequence.
怎样找出一个序列中出现次数最多的元素呢

The collections.Counter class is designed for just such a problem.
collections.Counter 类就是专门为这类问题而设计的， 它甚至有一个有用的 most_common() 方法直接给了你答案

To illustrate, let’s say you have a list of words and you want to find out which words occur most often.
为了演示，先假设你有一个单词列表并且想找出哪个单词出现频率最高

Here’s how you would do it:
你可以这样做：

As input, Counter objects can be fed any sequence of hashable input items.
作为输入， Counter 对象可以接受任意的由可哈希(hashable)元素构成的序列对象

Under the covers, a Counter is a dictionary that maps the items to the number of occurrences.
 在底层实现上，一个 Counter 对象就是一个字典，将元素映射到它出现的次数上

For example:
比如：

If you want to increment the count manually, simply use addition:
如果你想手动增加计数，可以简单的用加法：

Or, alternatively, you could use the update() method:
或者你可以使用 update() 方法：

A little-known feature of Counter instances is that they can be easily combined using various mathematical operations.
Counter 实例一个鲜为人知的特性是它们可以很容易的跟数学运算操作相结合

For example:
比如：

Needless to say, Counter objects are a tremendously useful tool for almost any kind of problem where you need to tabulate and count data.
毫无疑问， Counter 对象在几乎所有需要制表或者计数数据的场合是非常有用的工具

You should prefer this over manually written solutions involving dictionaries.
 在解决这类问题的时候你应该优先选择它，而不是手动的利用字典去实现

Sorting a List of Dictionaries by a Common Key
1.13 通过某个关键字排序一个字典列表¶

You have a list of dictionaries and you would like to sort the entries according to one or more of the dictionary values.
你有一个字典列表，你想根据某个或某几个字典字段来排序这个列表

Sorting this type of structure is easy using the operator module’s itemgetter function.
通过使用 operator 模块的 itemgetter 函数，可以非常容易的排序这样的数据结构

Let’s say you’ve queried a database table to get a listing of the members on your website, and you receive the following data structure in return:
 假设你从数据库中检索出来网站会员信息列表，并且以下列的数据结构返回：

It’s fairly easy to output these rows ordered by any of the fields common to all of the dictionaries.
根据任意的字典字段来排序输入结果行是很容易实现的，代码示例：

The preceding code would output the following:
代码的输出如下：

The itemgetter() function can also accept multiple keys.
itemgetter() 函数也支持多个keys，比如下面的代码

Produces output like this:
会产生如下的输出：

In this example, rows is passed to the built-in sorted() function, which accepts a keyword argument key.
在上面例子中， rows 被传递给接受一个关键字参数的 sorted() 内置函数

This argument is expected to be a callable that accepts a single item from rows as input and returns a value that will be used as the basis for sorting.
 这个参数是 callable 类型，并且从 rows 中接受一个单一元素，然后返回被用来排序的值

The itemgetter() function creates just such a callable.
 itemgetter() 函数就是负责创建这个 callable 对象的

The operator.itemgetter() function takes as arguments the lookup indices used to extract the desired values from the records in rows.
operator.itemgetter() 函数有一个被 rows 中的记录用来查找值的索引参数

It can be a dictionary key name, a numeric list element, or any value that can be fed to an object’s __getitem__() method.
可以是一个字典键名称， 一个整形值或者任何能够传入一个对象的 __getitem__() 方法的值

If you give multiple indices to itemgetter(), the callable it produces will return a tuple with all of the elements in it, and sorted() will order the output according to the sorted order of the tuples.
 如果你传入多个索引参数给 itemgetter() ，它生成的 callable 对象会返回一个包含所有元素值的元组， 并且 sorted() 函数会根据这个元组中元素顺序去排序

This can be useful if you want to simultaneously sort on multiple fields (such as last and first name, as shown in the example).
 但你想要同时在几个字段上面进行排序(比如通过姓和名来排序，也就是例子中的那样)的时候这种方法是很有用的

The functionality of itemgetter() is sometimes replaced by lambda expressions.
itemgetter() 有时候也可以用 lambda 表达式代替，比如：

This solution often works just fine.
这种方案也不错

However, the solution involving itemgetter() typically runs a bit faster.
但是，使用 itemgetter() 方式会运行的稍微快点

Thus, you might prefer it if performance is a concern.
因此，如果你对性能要求比较高的话就使用 itemgetter() 方式

Last, but not least, don’t forget that the technique shown in this recipe can be applied to functions such as min() and max().
最后，不要忘了这节中展示的技术也同样适用于 min() 和 max() 等函数

For example:
比如：

Sorting Objects Without Native Comparison Support
1.14 排序不支持原生比较的对象¶

You want to sort objects of the same class, but they don’t natively support comparison operations.
你想排序类型相同的对象，但是他们不支持原生的比较操作

The built-in sorted() function takes a key argument that can be passed a callable that will return some value in the object that sorted will use to compare the objects.
内置的 sorted() 函数有一个关键字参数 key ，可以传入一个 callable 对象给它， 这个 callable 对象对每个传入的对象返回一个值，这个值会被 sorted 用来排序这些对象

For example, if you have a sequence of User instances in your application, and you want to sort them by their user_id attribute, you would supply a callable that takes a User instance as input and returns the user_id.
 比如，如果你在应用程序里面有一个 User 实例序列，并且你希望通过他们的 user_id 属性进行排序， 你可以提供一个以 User 实例作为输入并输出对应 user_id 值的 callable 对象

For example:
比如：

Instead of using lambda, an alternative approach is to use operator.attrgetter():
另外一种方式是使用 operator.attrgetter() 来代替lambda函数：

The choice of whether or not to use lambda or attrgetter() may be one of personal preference.
选择使用lambda函数或者是 attrgetter() 可能取决于个人喜好

However, attrgetter() is often a tad bit faster and also has the added feature of allowing multiple fields to be extracted simultaneously.
 但是， attrgetter() 函数通常会运行的快点，并且还能同时允许多个字段进行比较

This is analogous to the use of operator.itemgetter() for dictionaries (see “Sorting a List of Dictionaries by a Common Key”).
 这个跟 operator.itemgetter() 函数作用于字典类型很类似(参考1.13小节)

For example, if User instances also had a first_name and last_name attribute, you could perform a sort like this:
 例如，如果 User 实例还有一个 first_name 和 last_name 属性，那么可以向下面这样排序：

It is also worth noting that the technique used in this recipe can be applied to functions such as min() and max().
同样需要注意的是，这一小节用到的技术同样适用于像 min() 和 max() 之类的函数

For example:
比如：

Grouping Records Together Based on a Field
1.15 通过某个字段将记录分组¶

You have a sequence of dictionaries or instances and you want to iterate over the data in groups based on the value of a particular field, such as date.
你有一个字典或者实例的序列，然后你想根据某个特定的字段比如 date 来分组迭代访问

The itertools.groupby() function is particularly useful for grouping data together like this.
itertools.groupby() 函数对于这样的数据分组操作非常实用

To illustrate, suppose you have the following list of dictionaries:
 为了演示，假设你已经有了下列的字典列表：

Now suppose you want to iterate over the data in chunks grouped by date.
现在假设你想在按date分组后的数据块上进行迭代

To do it, first sort by the desired field (in this case, date) and then use itertools.groupby():
为了这样做，你首先需要按照指定的字段(这里就是 date )排序， 然后调用 itertools.groupby() 函数：

This produces the following output:
运行结果：

The groupby() function works by scanning a sequence and finding sequential "runs" of identical values (or values returned by the given key function).
groupby() 函数扫描整个序列并且查找连续相同值(或者根据指定key函数返回值相同)的元素序列

On each iteration, it returns the value along with an iterator that produces all of the items in a group with the same value.
 在每次迭代的时候，它会返回一个值和一个迭代器对象， 这个迭代器对象可以生成元素值全部等于上面那个值的组中所有对象

An important preliminary step is sorting the data according to the field of interest.
一个非常重要的准备步骤是要根据指定的字段将数据排序

Since groupby() only examines consecutive items, failing to sort first won’t group the records as you want.
 因为 groupby() 仅仅检查连续的元素，如果事先并没有排序完成的话，分组函数将得不到想要的结果

If your goal is to simply group the data together by dates into a large data structure that allows random access, you may have better luck using defaultdict() to build a multidict, as described in “Mapping Keys to Multiple Values in a Dictionary”.
如果你仅仅只是想根据 date 字段将数据分组到一个大的数据结构中去，并且允许随机访问， 那么你最好使用 defaultdict() 来构建一个多值字典，关于多值字典已经在1.6小节有过详细的介绍

For example:
比如：

This allows the records for each date to be accessed easily like this:
这样的话你可以很轻松的就能对每个指定日期访问对应的记录：

For this latter example, it’s not necessary to sort the records first.
在上面这个例子中，我们没有必要先将记录排序

Thus, if memory is no concern, it may be faster to do this than to first sort the records and iterate using groupby().
因此，如果对内存占用不是很关心， 这种方式会比先排序然后再通过 groupby() 函数迭代的方式运行得快一些

Filtering Sequence Elements
1.16 过滤序列元素¶

You have data inside of a sequence, and need to extract values or reduce the sequence using some criteria.
你有一个数据序列，想利用一些规则从中提取出需要的值或者是缩短序列

The easiest way to filter sequence data is often to use a list comprehension.
最简单的过滤序列元素的方法就是使用列表推导

For example:
比如：

One potential downside of using a list comprehension is that it might produce a large result if the original input is large.
使用列表推导的一个潜在缺陷就是如果输入非常大的时候会产生一个非常大的结果集，占用大量内存

If this is a concern, you can use generator expressions to produce the filtered values iteratively.
 如果你对内存比较敏感，那么你可以使用生成器表达式迭代产生过滤的元素

For example:
比如：

Sometimes, the filtering criteria cannot be easily expressed in a list comprehension or generator expression.
有时候，过滤规则比较复杂，不能简单的在列表推导或者生成器表达式中表达出来

For example, suppose that the filtering process involves exception handling or some other complicated detail.
 比如，假设过滤的时候需要处理一些异常或者其他复杂情况

For this, put the filtering code into its own function and use the built-in filter() function.
这时候你可以将过滤代码放到一个函数中， 然后使用内建的 filter() 函数

For example:
示例如下：

filter() creates an iterator, so if you want to create a list of results, make sure you also use list() as shown.
filter() 函数创建了一个迭代器，因此如果你想得到一个列表的话，就得像示例那样使用 list() 去转换

List comprehensions and generator expressions are often the easiest and most straightforward ways to filter simple data.
列表推导和生成器表达式通常情况下是过滤数据最简单的方式

They also have the added power to transform the data at the same time.
 其实它们还能在过滤的时候转换数据

For example:
比如：

One variation on filtering involves replacing the values that don’t meet the criteria with a new value instead of discarding them.
过滤操作的一个变种就是将不符合条件的值用新的值代替，而不是丢弃它们

For example, perhaps instead of just finding positive values, you want to also clip bad values to fit within a specified range.
 比如，在一列数据中你可能不仅想找到正数，而且还想将不是正数的数替换成指定的数

This is often easily accomplished by moving the filter criterion into a conditional expression like this:
 通过将过滤条件放到条件表达式中去，可以很容易的解决这个问题，就像这样：

Another notable filtering tool is itertools.compress(), which takes an iterable and an accompanying Boolean selector sequence as input.
另外一个值得关注的过滤工具就是 itertools.compress() ， 它以一个 iterable 对象和一个相对应的 Boolean 选择器序列作为输入参数

As output, it gives you all of the items in the iterable where the corresponding element in the selector is True.
 然后输出 iterable 对象中对应选择器为 True 的元素

This can be useful if you’re trying to apply the results of filtering one sequence to another related sequence.
 当你需要用另外一个相关联的序列来过滤某个序列的时候，这个函数是非常有用的

For example, suppose you have the following two columns of data:
 比如，假如现在你有下面两列数据：

Now suppose you want to make a list of all addresses where the corresponding count value was greater than 5.
现在你想将那些对应 count 值大于5的地址全部输出，那么你可以这样做：

The key here is to first create a sequence of Booleans that indicates which elements satisfy the desired condition.
这里的关键点在于先创建一个 Boolean 序列，指示哪些元素符合条件

The compress() function then picks out the items corresponding to True values.
 然后 compress() 函数根据这个序列去选择输出对应位置为 True 的元素

Like filter(), compress() normally returns an iterator.
和 filter() 函数类似， compress() 也是返回的一个迭代器

Thus, you need to use list() to turn the results into a list if desired.
因此，如果你需要得到一个列表， 那么你需要使用 list() 来将结果转换为列表类型

Extracting a Subset of a Dictionary
1.17 从字典中提取子集¶

You want to make a dictionary that is a subset of another dictionary.
你想构造一个字典，它是另外一个字典的子集

This is easily accomplished using a dictionary comprehension.
最简单的方式是使用字典推导

For example:
比如：

Much of what can be accomplished with a dictionary comprehension might also be done by creating a sequence of tuples and passing them to the dict() function.
大多数情况下字典推导能做到的，通过创建一个元组序列然后把它传给 dict() 函数也能实现

For example:
比如：

However, the dictionary comprehension solution is a bit clearer and actually runs quite a bit faster (over twice as fast when tested on the prices dictionary used in the example).
但是，字典推导方式表意更清晰，并且实际上也会运行的更快些 (在这个例子中，实际测试几乎比 dcit() 函数方式快整整一倍)

Sometimes there are multiple ways of accomplishing the same thing.
有时候完成同一件事会有多种方式

For instance, the second example could be rewritten as:
比如，第二个例子程序也可以像这样重写：

However, a timing study reveals that this solution is almost 1.6 times slower than the first solution.
但是，运行时间测试结果显示这种方案大概比第一种方案慢1.6倍

If performance matters, it usually pays to spend a bit of time studying it.
 如果对程序运行性能要求比较高的话，需要花点时间去做计时测试

See “Profiling and Timing Your Program” for specific information about timing and profiling.
 关于更多计时和性能测试，可以参考14.13小节

Mapping Names to Sequence Elements
1.18 映射名称到序列元素¶

You have code that accesses list or tuple elements by position, but this makes the code somewhat difficult to read at times.
你有一段通过下标访问列表或者元组中元素的代码，但是这样有时候会使得你的代码难以阅读， 于是你想通过名称来访问元素

collections.namedtuple() provides these benefits, while adding minimal overhead over using a normal tuple object.
collections.namedtuple() 函数通过使用一个普通的元组对象来帮你解决这个问题

collections.namedtuple() is actually a factory method that returns a subclass of the standard Python tuple type.
 这个函数实际上是一个返回Python中标准元组类型子类的一个工厂方法

You feed it a type name, and the fields it should have, and it returns a class that you can instantiate, passing in values for the fields you’ve defined, and so on.
 你需要传递一个类型名和你需要的字段给它，然后它就会返回一个类，你可以初始化这个类，为你定义的字段传递值等

For example:
 代码示例：

Although an instance of a namedtuple looks like a normal class instance, it is interchangeable with a tuple and supports all of the usual tuple operations such as indexing and unpacking.
尽管 namedtuple 的实例看起来像一个普通的类实例，但是它跟元组类型是可交换的，支持所有的普通元组操作，比如索引和解压

For example:
 比如：

A major use case for named tuples is decoupling your code from the position of the elements it manipulates.
命名元组的一个主要用途是将你的代码从下标操作中解脱出来

So, if you get back a large list of tuples from a database call, then manipulate them by accessing the positional elements, your code could break if, say, you added a new column to your table.
 因此，如果你从数据库调用中返回了一个很大的元组列表，通过下标去操作其中的元素， 当你在表中添加了新的列的时候你的代码可能就会出错了

Not so if you first cast the returned tuples to namedtuples.
但是如果你使用了命名元组，那么就不会有这样的顾虑

To illustrate, here is some code using ordinary tuples:
为了说明清楚，下面是使用普通元组的代码：

References to positional elements often make the code a bit less expressive and more dependent on the structure of the records.
下标操作通常会让代码表意不清晰，并且非常依赖记录的结构

Here is a version that uses a namedtuple:
 下面是使用命名元组的版本：

Naturally, you can avoid the explicit conversion to the Stock namedtuple if the records sequence in the example already contained such instances.
命名元组另一个用途就是作为字典的替代，因为字典存储需要更多的内存空间

One possible use of a namedtuple is as a replacement for a dictionary, which requires more space to store.
如果你需要构建一个非常大的包含字典的数据结构，那么使用命名元组会更加高效

Thus, if you are building large data structures involving dictionaries, use of a namedtuple will be more efficient.
 但是需要注意的是，不像字典那样，一个命名元组是不可更改的

However, be aware that unlike a dictionary, a namedtuple is immutable.
比如：

If you need to change any of the attributes, it can be done using the _replace() method of a namedtuple instance, which makes an entirely new namedtuple with specified values replaced.
如果你真的需要改变属性的值，那么可以使用命名元组实例的 _replace() 方法， 它会创建一个全新的命名元组并将对应的字段用新的值取代

For example:
比如：

A subtle use of the _replace() method is that it can be a convenient way to populate named tuples that have optional or missing fields.
_replace() 方法还有一个很有用的特性就是当你的命名元组拥有可选或者缺失字段时候， 它是一个非常方便的填充数据的方法

To do this, you make a prototype tuple containing the default values and then use _replace() to create new instances with values replaced.
 你可以先创建一个包含缺省值的原型元组，然后使用 _replace() 方法创建新的值被更新过的实例

For example:
比如：

Here is an example of how this code would work:
下面是它的使用方法：

Last, but not least, it should be noted that if your goal is to define an efficient data structure where you will be changing various instance attributes, using namedtuple is not your best choice.
最后要说的是，如果你的目标是定义一个需要更新很多实例属性的高效数据结构，那么命名元组并不是你的最佳选择

Instead, consider defining a class using __slots__ instead (see “Saving Memory When Creating a Large Number of Instances”).
 这时候你应该考虑定义一个包含 __slots__ 方法的类(参考8.4小节)

Transforming and Reducing Data at the Same Time
1.19 转换并同时计算数据¶

You need to execute a reduction function (e.g., sum(), min(), max()), but first need to transform or filter the data.
你需要在数据序列上执行聚集函数(比如 sum() , min() , max() )， 但是首先你需要先转换或者过滤数据

A very elegant way to combine a data reduction and a transformation is to use a generator-expression argument.
一个非常优雅的方式去结合数据计算与转换就是使用一个生成器表达式参数

For example, if you want to calculate the sum of squares, do the following:
 比如，如果你想计算平方和，可以像下面这样做：

Here are a few other examples:
下面是更多的例子：

The solution shows a subtle syntactic aspect of generator expressions when supplied as the single argument to a function (i.e., you don’t need repeated parentheses).
上面的示例向你演示了当生成器表达式作为一个单独参数传递给函数时候的巧妙语法(你并不需要多加一个括号)

For example, these statements are the same:
 比如，下面这些语句是等效的：

Using a generator argument is often a more efficient and elegant approach than first creating a temporary list.
使用一个生成器表达式作为参数会比先创建一个临时列表更加高效和优雅

For example, if you didn’t use a generator expression, you might consider this alternative implementation:
 比如，如果你不使用生成器表达式的话，你可能会考虑使用下面的实现方式：

This works, but it introduces an extra step and creates an extra list.
这种方式同样可以达到想要的效果，但是它会多一个步骤，先创建一个额外的列表

For such a small list, it might not matter, but if nums was huge, you would end up creating a large temporary data structure to only be used once and discarded.
 对于小型列表可能没什么关系，但是如果元素数量非常大的时候， 它会创建一个巨大的仅仅被使用一次就被丢弃的临时数据结构

The generator solution transforms the data iteratively and is therefore much more memory-efficient.
而生成器方案会以迭代的方式转换数据，因此更省内存

Certain reduction functions such as min() and max() accept a key argument that might be useful in situations where you might be inclined to use a generator.
在使用一些聚集函数比如 min() 和 max() 的时候你可能更加倾向于使用生成器版本， 它们接受的一个key关键字参数或许对你很有帮助

For example, in the portfolio example, you might consider this alternative:
 比如，在上面的证券例子中，你可能会考虑下面的实现版本：

Combining Multiple Mappings into a Single Mapping
1.20 合并多个字典或映射¶

You have multiple dictionaries or mappings that you want to logically combine into a single mapping to perform certain operations, such as looking up values or checking for the existence of keys.
现在有多个字典或者映射，你想将它们从逻辑上合并为一个单一的映射后执行某些操作， 比如查找值或者检查某些键是否存在

Suppose you have two dictionaries:
假如你有如下两个字典:

Now suppose you want to perform lookups where you have to check both dictionaries (e.g., first checking in a and then in b if not found).
现在假设你必须在两个字典中执行查找操作(比如先从 a 中找，如果找不到再在 b 中找)

An easy way to do this is to use the ChainMap class from the collections module.
 一个非常简单的解决方案就是使用 collections 模块中的 ChainMap 类

For example:
比如：

A ChainMap takes multiple mappings and makes them logically appear as one.
一个 ChainMap 接受多个字典并将它们在逻辑上变为一个字典

However, the mappings are not literally merged together.
 然后，这些字典并不是真的合并在一起了， ChainMap 类只是在内部创建了一个容纳这些字典的列表 并重新定义了一些常见的字典操作来遍历这个列表

Instead, a ChainMap simply keeps a list of the underlying mappings and redefines common dictionary operations to scan the list.
大部分字典操作都是可以正常使用的，比如：

If there are duplicate keys, the values from the first mapping get used.
如果出现重复键，那么第一次出现的映射值会被返回

Thus, the entry c['z'] in the example would always refer to the value in dictionary a, not the value in dictionary b.
 因此，例子程序中的 c['z'] 总是会返回字典 a 中对应的值，而不是 b 中对应的值

Operations that mutate the mapping always affect the first mapping listed.
对于字典的更新或删除操作总是影响的是列表中第一个字典

For example:
比如：

A ChainMap is particularly useful when working with scoped values such as variables in a programming language (i.e., globals, locals, etc.).
ChainMap 对于编程语言中的作用范围变量(比如 globals , locals 等)是非常有用的

In fact, there are methods that make this easy:
 事实上，有一些方法可以使它变得简单：

As an alternative to ChainMap, you might consider merging dictionaries together using the update() method.
作为 ChainMap 的替代，你可能会考虑使用 update() 方法将两个字典合并

For example:
比如：

This works, but it requires you to make a completely separate dictionary object (or destructively alter one of the existing dictionaries).
这样也能行得通，但是它需要你创建一个完全不同的字典对象(或者是破坏现有字典结构)

Also, if any of the original dictionaries mutate, the changes don’t get reflected in the merged dictionary.
 同时，如果原字典做了更新，这种改变不会反应到新的合并字典中去

For example:
比如：

A ChainMap uses the original dictionaries, so it doesn’t have this behavior.
ChainMap 使用原来的字典，它自己不创建新的字典

For example:
所以它并不会产生上面所说的结果，比如：

