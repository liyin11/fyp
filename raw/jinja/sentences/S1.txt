Navigation
Navigation

This document describes the API to Jinja2 and not the template language.
本文档描述 Jinja2 的 API 而不是模板语言

It will be most useful as reference to those implementing the template interface to the application and not those who are creating Jinja2 templates.
这对实现模板接口，而非创建 Jinja2 模板，是最有用的参考，

Basics¶
基础¶

Jinja2 uses a central object called the template Environment.
Jinja2 使用一个名为 Environment 的中心对象

Instances of this class are used to store the configuration and global objects, and are used to load templates from the file system or other locations.
这个类的实例用于存储配 置、全局对象，并用于从文件系统或其它位置加载模板

Even if you are creating templates from strings by using the constructor of Template class, an environment is created automatically for you, albeit a shared one.
即使你通过:class:Template 类的构造函数用字符串创建模板，也会为你自动创建一个环境，尽管是共享的

Most applications will create one Environment object on application initialization and use that to load templates.
大多数应用在应用初始化时创建一个 Environment 对象，并用它加载模板

In some cases however, it’s useful to have multiple environments side by side, if different configurations are in use.
 在某些情况下，如果使用多份配置，使用并列的多个环境无论如何是有用的

The simplest way to configure Jinja2 to load templates for your application looks roughly like this:
配置 Jinja2 为你的应用加载文档的最简单方式看起来大概是这样:

This will create a template environment with the default settings and a loader that looks up the templates in the templates folder inside the yourapplication python package.
这会创建一个默认设定下的模板环境和一个在 yourapplication python 包中的 templates 文件夹中寻找模板的加载器

Different loaders are available and you can also write your own if you want to load templates from a database or other resources.
多个加载器是可用的，如果你需要从 数据库或其它资源加载模板，你也可以自己写一个

To load a template from this environment you just have to call the get_template() method which then returns the loaded Template:
你只需要调用 get_template() 方法从这个环境中加载模板，并会返回已加载的 Template:

To render it with some variables, just call the render() method:
用若干变量来渲染它，调用 render() 方法:

Using a template loader rather than passing strings to Template or Environment.from_string() has multiple advantages.
使用一个模板加载器，而不是向 Template 或 Environment.from_string() 传递字符串，有许多好处

Besides being a lot easier to use it also enables template inheritance.
除了使用上便利， 也使得模板继承成为可能

Unicode¶
Unicode¶

Jinja2 is using Unicode internally which means that you have to pass Unicode objects to the render function or bytestrings that only consist of ASCII characters.
Jinja2 内部使用 Unicode ，这意味着你需要向渲染函数传递 Unicode 对象或只包含 ASCII 字符的字符串

Additionally newlines are normalized to one end of line sequence which is per default UNIX style (\n).
此外，换行符按照默认 UNIX 风格规定行序列结束（ \n ）

Python 2.x supports two ways of representing string objects.
Python 2.x 支持两种表示字符串对象的方法

One is the str type and the other is the unicode type, both of which extend a type called basestring.
一种是 str 类型，另一种是 unicode 类型，它们都继承于 basestring 类型

Unfortunately the default is str which should not be used to store text based information unless only ASCII characters are used.
不幸的是，默认的 str 不 应该用于存储基于文本的信息，除非只用到 ASCII 字符

With Python 2.6 it is possible to make unicode the default on a per module level and with Python 3 it will be the default.
在 Python 2.6 中，可以 在模块层指定 unicode 为默认值，而在 Python 3 中会是默认值

To explicitly use a Unicode string you have to prefix the string literal with a u: u'Hänsel und Gretel sagen Hallo'.
要显式使用一个 Unicode 字符串，你需要给字符串字面量加上 u 前缀： u'Hänsel und Gretel sagen Hallo' 

That way Python will store the string as Unicode by decoding the string with the character encoding from the current Python module.
这样 Python 会用当前模块的字符编码来 解码字符串，来把字符串存储为 Unicode 

If no encoding is specified this defaults to ‘ASCII’ which means that you can’t use any non ASCII identifier.
如果没有指定编码，默认是 ASCII ， 这意味着你不能使用任何非 ASCII 的标识符

To set a better module encoding add the following comment to the first or second line of the Python module using the Unicode literal:
在使用 Unicode 字面量的 Python 模块的首行或第二行添加下面的注释，来妥善设 置模块编码:

We recommend utf-8 as Encoding for Python modules and templates as it’s possible to represent every Unicode character in utf-8 and because it’s backwards compatible to ASCII.
我们推荐为 Python 模块和模板使用 utf-8 编码，因为在 utf-8 中，可以表示 Unicode 中的每个字符，并且向后兼容 ASCII 

For Jinja2 the default encoding of templates is assumed to be utf-8.
对于 Jinja2 ，模板的默认编码 假定为 utf-8 

It is not possible to use Jinja2 to process non-Unicode data.
用 Jinja2 来处理非 Unicode 数据是不可能的

The reason for this is that Jinja2 uses Unicode already on the language level.
这是因为 Jinja2 已经在语言层 使用了 Unicode 

For example Jinja2 treats the non-breaking space as valid whitespace inside expressions which requires knowledge of the encoding or operating on an Unicode string.
例如 Jinja2 在表达式中把不间断空格视为有效的空格，这需要 获悉编码或操作一个 Unicode 字符串

For more details about Unicode in Python have a look at the excellent Unicode documentation.
关于 Python 中 Unicode 的更多细节，请阅读完善的 Unicode documentation 

Another important thing is how Jinja2 is handling string literals in templates.
另一件重要的事情是 Jinja2 如何处理模板中的字符串字面量

A naive implementation would be using Unicode strings for all string literals but it turned out in the past that this is problematic as some libraries are typechecking against str explicitly.
原生实现会对所有 字符串字面量使用 Unicode ，但在过去这是有问题的，因为一些库显式地检查它 们的类型是否为 str 

For example datetime.strftime does not accept Unicode arguments.
例如 datetime.strftime 不接受 Unicode 参数

To not break it completely Jinja2 is returning str for strings that fit into ASCII and for everything else unicode:
 为了不彻底破坏它， Jinja2 对只有 ASCII 的字符串返回 str，而对其它返回 unicode:

High Level API¶
高层 API¶

The high-level API is the API you will use in the application to load and render Jinja2 templates.
高层 API 即是你会在应用中用于加载并渲染模板的 API 

The Low Level API on the other side is only useful if you want to dig deeper into Jinja2 or develop extensions.
 低层 API 相反，只在你想深入挖掘 Jinja2 或 开发扩展 时有用

The core component of Jinja is the Environment.
The core component of Jinja is the Environment. It contains important shared variables like configuration, filters, tests, globals and others. Instances of this class may be modified if they are not shared and if no template was loaded so far. Modifications on environments after the first template was loaded will lead to surprising effects and undefined behavior.

Here are the possible initialization parameters:
Here the possible initialization parameters:

If given and a string, this will be used as prefix for line based comments.
If given and a string, this will be used as prefix for line based based comments. See also 行语句.

New in version 2.2.
New in version 2.2.

Preserve the trailing newline when rendering templates.
Preserve the trailing newline when rendering templates. The default is False, which causes a single newline, if present, to be stripped from the end of the template.

New in version 2.7.
New in version 2.7.

If set to True the XML/HTML autoescaping feature is enabled by default.
If set to true the XML/HTML autoescaping feature is enabled by default. For more details about auto escaping see Markup. As of Jinja 2.4 this can also be a callable that is passed the template name and has to return True or False depending on autoescape should be enabled by default.

Changed in version 2.4: autoescape can now be a function
Changed in version 2.4: autoescape can now be a function

The size of the cache.
If set to a bytecode cache object, this object will provide a cache for the internal Jinja bytecode so that templates don’t have to be parsed if they were not changed.

Changed in version 2.8: The cache size was increased to 400 from a low 50.
See 字节码缓存 for more information.

If set to a bytecode cache object, this object will provide a cache for the internal Jinja bytecode so that templates don’t have to be parsed if they were not changed.
如果模板通过 Template 构造函数创建，会自动创建一个环境

See Bytecode Cache for more information.
如果环境在沙箱中，这个属性为 True 

If a template was created by using the Template constructor an environment is created automatically.
该环境的过滤器字典

These environments are created as shared environments which means that multiple templates may have the same anonymous environment.
只要没有加载过模板，添加新过滤器或删除旧的都是 安全的

For all shared environments this attribute is True, else False.
自定义过滤器见 自定义过滤器 

If the environment is sandboxed this attribute is True.
该环境的测试函数字典

For the sandbox mode have a look at the documentation for the SandboxedEnvironment.
只要没有加载过模板，修改这个字典都是安全的

A dict of filters for this environment.
一个全局变量字典

As long as no template was loaded it’s safe to add new filters or remove old.
这些变量在模板中总是可用

For custom filters see Custom Filters.
只要没有加载过模板，修 改这个字典都是安全的

For valid filter names have a look at Notes on Identifiers.
更多细节见 全局命名空间 

A dict of test functions for this environment.
Create a new overlay environment that shares all the data with the current environment except of cache and the overridden attributes. Extensions cannot be removed for an overlayed environment. An overlayed environment automatically gets all the extensions of the environment it is linked to plus optional extra extensions.

A dict of global variables.
Creating overlays should happen after the initial environment was set up completely. Not all attributes are truly linked, some are just copied over so modifications on the original environment may not shine through.

The class used for code generation.
为 name 创建一个新 Undefined 对象

This should not be changed in most cases, unless you need to modify the Python code a template compiles to.
这对可能为某些操作返回 未定义对象过滤器和函数有用

The context used for templates.
创建一个未定义对象的最常用方法是只提供名称:

Create a new overlay environment that shares all the data with the current environment except for cache and the overridden attributes.
这意味着名称 some_name 未被定义

Extensions cannot be removed for an overlayed environment.
如果名称来自一个对象的属性，把 持有它的对象告知未定义对象对丰富错误消息很有意义:

Creating overlays should happen after the initial environment was set up completely.
更复杂的例子中，你可以提供一个 hint 

Not all attributes are truly linked, some are just copied over so modifications on the original environment may not shine through.
例如 first() 过滤器 用这种方法创建一个未定义对象:

Creates a new Undefined object for name.
如果 name 或 obj 是已知的（比如访问了了一个属性），它应该传递给 未定义对象，即使提供了自定义的 hint 

This is useful for filters or functions that may return undefined objects for some operations.
这让未定义对象有可能增强错误 消息

The most common way to create an undefined object is by providing a name only:
Adds an extension after the environment was created.

This means that the name some_name is not defined.
New in version 2.5.

For a more complex example you can provide a hint.
A handy helper method that returns a callable that accepts keyword arguments that appear as variables in the expression. If called it returns the result of the expression.

If it the name or obj is known (for example because an attribute was accessed) it should be passed to the undefined object, even if a custom hint is provided.
This is useful if applications want to use the same rules as Jinja in template “configuration files” or similar situations.

Adds an extension after the environment was created.
Example usage:

New in version 2.5.
Per default the return value is converted to None if the expression returns an undefined value. This can be changed by setting undefined_to_none to False.

A handy helper method that returns a callable that accepts keyword arguments that appear as variables in the expression.
New in version 2.1.

This is useful if applications want to use the same rules as Jinja in template “configuration files” or similar situations.
Finds all the templates the loader can find, compiles them and stores them in target. If zip is None, instead of in a zipfile, the templates will be will be stored in a directory. By default a deflate zip algorithm is used, to switch to the stored algorithm, zip can be set to 'stored'.

Example usage:
extensions and filter_func are passed to list_templates(). Each template returned will be compiled to the target folder or zipfile.

Per default the return value is converted to None if the expression returns an undefined value.
By default template compilation errors are ignored. In case a log function is provided, errors are logged. If you want template syntax errors to abort the compilation you can set ignore_errors to False and you will get an exception on syntax errors.

New in version 2.1.
If py_compile is set to True .pyc files will be written to the target instead of standard .py files. This flag does not do anything on pypy and Python 3 where pyc files are not picked up by itself and don’t give much benefit.

Finds all the templates the loader can find, compiles them and stores them in target.
New in version 2.4.

extensions and filter_func are passed to list_templates().
Add the items to the instance of the environment if they do not exist yet. This is used by extensions to register callbacks and configuration values without breaking inheritance.

By default template compilation errors are ignored.
Load a template from a string. This parses the source given and returns a Template object.

If py_compile is set to True .pyc files will be written to the target instead of standard .py files.
Does a typecheck and dispatches to select_template() if an iterable of template names is given, otherwise to get_template().

New in version 2.4.
New in version 2.3.

Add the items to the instance of the environment if they do not exist yet.
Load a template from the loader. If a loader is configured this method ask the loader for the template and returns a Template. If the parent parameter is not None, join_path() is called to get the real template name before loading.

Load a template from a string.
The globals parameter can be used to provide template wide globals. These variables are available in the context at render time.

Does a typecheck and dispatches to select_template() if an iterable of template names is given, otherwise to get_template().
If the template does not exist a TemplateNotFound exception is raised.

New in version 2.3.
Changed in version 2.4: If name is a Template object it is returned from the function unchanged.

Load a template from the loader.
Join a template with the parent. By default all the lookups are relative to the loader root so this method returns the template parameter unchanged, but if the paths should be relative to the parent template, this function can be used to calculate the real template name.

The globals parameter can be used to provide template wide globals.
Subclasses may override this method and implement template path joining here.

If the template does not exist a TemplateNotFound exception is raised.
Returns a list of templates for this environment. This requires that the loader supports the loader’s list_templates() method.

Changed in version 2.4: If name is a Template object it is returned from the function unchanged.
If there are other files in the template folder besides the actual templates, the returned list can be filtered. There are two ways: either extensions is set to a list of file extensions for templates, or a filter_func can be provided which is a callable that is passed a template name and should return True if it should end up in the result list.

Join a template with the parent.
If the loader does not support that, a TypeError is raised.

Subclasses may override this method and implement template path joining here.
New in version 2.4.

Returns a list of templates for this environment.
Works like get_template() but tries a number of templates before it fails. If it cannot find any of the templates, it will raise a TemplatesNotFound exception.

If there are other files in the template folder besides the actual templates, the returned list can be filtered.
New in version 2.3.

If the loader does not support that, a TypeError is raised.
Changed in version 2.4: If names contains a Template object it is returned from the function unchanged.

New in version 2.4.
The central template object. This class represents a compiled template and is used to evaluate it.

Works like get_template() but tries a number of templates before it fails.
Normally the template object is generated from an Environment but it also has a constructor that makes it possible to create a template instance directly using the constructor. It takes the same arguments as the environment constructor but it’s not possible to specify a loader.

New in version 2.3.
Every template object has a few methods and members that are guaranteed to exist. However it’s important that a template object should be considered immutable. Modifications on the object are not supported.

Changed in version 2.4: If names contains a Template object it is returned from the function unchanged.
Template objects created from the constructor rather than an environment do have an environment attribute that points to a temporary environment that is probably shared with other templates created with the constructor and compatible settings.

The central template object.
该模板的全局变量字典

This class represents a compiled template and is used to evaluate it.
修改这个字典是不安全的，因为它可能与其它模板或 加载这个模板的环境共享

Normally the template object is generated from an Environment but it also has a constructor that makes it possible to create a template instance directly using the constructor.
模板的加载名

It takes the same arguments as the environment constructor but it’s not possible to specify a loader.
如果模板从字符串加载，这个值为 None 

Every template object has a few methods and members that are guaranteed to exist.
模板在文件系统上的文件名，如果没有从文件系统加载，这个值为 None 

Template objects created from the constructor rather than an environment do have an environment attribute that points to a temporary environment that is probably shared with other templates created with the constructor and compatible settings.
This method accepts the same arguments as the dict constructor: A dict, a dict subclass or some keyword arguments. If no arguments are given the context will be empty. These two calls do the same:

The dict with the globals of that template.
This will return the rendered template as unicode string.

The loading name of the template.
For very large templates it can be useful to not render the whole template at once but evaluate each statement after another and yield piece for piece. This method basically does exactly that and returns a generator that yields one item after another as unicode strings.

The filename of the template on the file system if it was loaded from there.
It accepts the same arguments as render().

This method accepts the same arguments as the dict constructor: A dict, a dict subclass or some keyword arguments.
Works exactly like generate() but returns a TemplateStream.

This will return the rendered template as unicode string.
This method works like the module attribute when called without arguments but it will evaluate the template on every call rather than caching it. It’s also possible to provide a dict which is then used as context. The arguments are the same as for the new_context() method.

For very large templates it can be useful to not render the whole template at once but evaluate each statement after another and yield piece for piece.
The template as module. This is used for imports in the template runtime but is also useful if one wants to access exported template variables from the Python layer:

It accepts the same arguments as render().
A template stream works pretty much like an ordinary python generator but it can buffer multiple items to reduce the number of total iterations. Per default the output is unbuffered which means that for every unbuffered instruction in the template one unicode string is yielded.

Works exactly like generate() but returns a TemplateStream.
If buffering is enabled with a buffer size of 5, five items are combined into a new unicode string. This is mainly useful if you are streaming big templates to a client via WSGI which flushes after each iteration.

This method works like the module attribute when called without arguments but it will evaluate the template on every call rather than caching it.
Disable the output buffering.

The template as module.
Dump the complete stream into a file or file-like object. Per default unicode strings are written, if you want to encode before writing specify an encoding.

A template stream works pretty much like an ordinary python generator but it can buffer multiple items to reduce the number of total iterations.
Example usage:

If buffering is enabled with a buffer size of 5, five items are combined into a new unicode string.
Enable buffering. Buffer size items before yielding them.

Example usage:
New in version 2.4.

Enable buffering.
从 Jinja 2.4 开始，自动转义的首选途径就是启用 自动转义扩展 并为自动转义配置一个合适的默认值

Buffer size items before yielding them.
这使得在单个模板基础上开关自动转义成为 可能（比如 HTML 对 文本）

As of Jinja 2.4 the preferred way to do autoescaping is to enable the Autoescape Extension and to configure a sensible default for autoescaping.
假设实现一个自动转义函数，确保你也视 None 为有效模板名接受

This makes it possible to enable and disable autoescaping on a per-template basis (HTML versus text for instance).
这会在从字符 串生成模板时传递

Here a recommended setup that enables autoescaping for templates ending in '.html', '.htm' and '.xml' and disabling it by default for all other extensions:
可以用 autoescape 块在模板内临时地更改这种行为

Filters and tests are looked up in separate namespaces and have slightly modified identifier syntax.
过滤器和测试会在独立的命名空间中查找，与标识符语法有细微区别

Filters and tests may contain dots to group filters and tests by topic.
过滤器和测 试可以包含点，用于按主题给过滤器和测试分组

For example it’s perfectly valid to add a function into the filter dict and call it to.unicode.
例如，把一个名为 to.unicode 的函数添加到过滤器字典是完全有效的

The regular expression for filter and test identifiers is [a-zA-Z_][a-zA-Z0-9_]*(\.[a-zA-Z_][a-zA-Z0-9_]*)*`.
过滤器和测试标识符的正则表达式是 [a-zA-Z_][a-zA-Z0-9_]*(\.[a-zA-Z_][a-zA-Z0-9_]*)* 

Undefined Types¶
未定义类型¶

These classes can be used as undefined types.
这些类可以用作未定义类型

The Environment constructor takes an undefined parameter that can be one of those classes or a custom subclass of Undefined.
 Environment 的构造函数接受一个可以是 那些类或一个 Undefined 的自定义子类的 undefined 参数

Whenever the template engine is unable to look up a name or access an attribute one of those objects is created and returned.
无论何时， 这些对象创建或返回时，模板引擎都不能查出其名称或访问其属性

Some operations on undefined values are then allowed, others fail.
未定义值上的 某些操作之后是允许的，而其它的会失败

The closest to regular Python behavior is the StrictUndefined which disallows all operations beside testing if it’s an undefined object.
最接近常规 Python 行为的是 StrictUndefined ，如果它是一个未定义对象， 它不允许除了测试之外的一切操作

The default undefined type.
The default undefined type. This undefined type can be printed and iterated over, but every other access will raise an UndefinedError:

Either None or an unicode string with the error message for the undefined object.
None 或给未定义对象的错误消息 unicode 字符串

Either None or the owner object that caused the undefined object to be created (for example because an attribute does not exist).
None 或引起未定义对象创建的对象（例如一个属性不存在）

The name for the undefined variable / attribute or just None if no such information exists.
未定义变量/属性的名称，如果没有此类信息，留为 None 

The exception that the undefined object wants to raise.
未定义对象想要抛出的异常

This is usually one of UndefinedError or SecurityError.
这通常是 UndefinedError 或 SecurityError 之一

When called with any arguments this method raises _undefined_exception with an error message generated from the undefined hints stored on the undefined object.
参数任意，调用这个方法时会抛出带有由未定义对象上存储的未定义 hint 生成的错误信息的 _undefined_exception 异常

An undefined that returns the debug info when printed.
An undefined that returns the debug info when printed.

An undefined that barks on print and iteration as well as boolean tests and all kinds of comparisons.
An undefined that barks on print and iteration as well as boolean tests and all kinds of comparisons. In other words: you can do nothing with it except checking if it’s defined using the defined test.

There is also a factory function that can decorate undefined objects to implement logging on failures:
未定义对象由调用 undefined 创建

Given a logger object this returns a new undefined class that will log certain failures.
实现

Example:
Undefined 对象通过重载特殊的 __underscore__ 方法实现

New in version 2.8.
要禁用一个方法，重载它并抛出 _undefined_exception 

Undefined objects are implemented by overriding the special __underscore__ methods.
The template context holds the variables of a template. It stores the values passed to the template and also the names the template exports. Creating instances is neither supported nor useful as it’s created automatically at various stages of the template evaluation and should not be created by hand.

To disallow a method, just override it and raise _undefined_exception.
The context is immutable. Modifications on parent must not happen and modifications on vars are allowed from generated template code only. Template filters and global functions marked as contextfunction()s get the active context passed as first argument and are allowed to access the context read-only.

The context is immutable.
一个模板查找的只读全局变量的词典

Modifications on parent must not happen and modifications on vars are allowed from generated template code only.
这些变量可能来自另一个 Context ，或是 Environment.globals ，或是 Template.globals ，或指向一个由全局变量和传递到渲染函数的变 量联立的字典

Template filters and global functions marked as contextfunction()s get the active context passed as first argument and are allowed to access the context read-only.
它一定不能被修改

The template context supports read only dict operations (get, keys, values, items, iterkeys, itervalues, iteritems, __getitem__, __contains__).
模板局域变量

Additionally there is a resolve() method that doesn’t fail with a KeyError but returns an Undefined object for missing variables.
这个列表包含环境和来自 parent 范围的上下文函数 以及局域修改和从模板中导出的变量

A dict of read only, global variables the template looks up.
加载该模板的环境

The template local variables.
这设定了所有模板导出量的名称

This list contains environment and context functions from the parent scope as well as local modifications and exported variables from the template.
名称对应的值在 vars 字典中

The template will modify this dict during template evaluation but filters and context functions are not allowed to modify it.
 可以用 get_exported() 获取一份导出变量的拷贝字典

The environment that loaded the template.
拥有此上下文的模板的载入名

This set contains all the names the template exports.
模板中块当前映射的字典

The values for the names are in the vars dict.
字典中的键是块名称，值是注册的块的列表

In order to get a copy of the exported variables as dict, get_exported() can be used.
每个 列表的最后一项是当前活动的块（继承链中最新的）

The load name of the template owning this context.
当前的 求值上下文 

A dict with the current mapping of blocks in the template.
Call the callable with the arguments and keyword arguments provided but inject the active context or environment as first argument if the callable is a contextfunction() or environmentfunction().

The current Evaluation Context.
Return a copy of the complete context as dict including the exported variables.

Call the callable with the arguments and keyword arguments provided but inject the active context or environment as first argument if the callable is a contextfunction() or environmentfunction().
Get a new dict with the exported variables.

Return a copy of the complete context as dict including the exported variables.
Looks up a variable like __getitem__ or get but returns an Undefined object with the name of the name looked up.

Get a new dict with the exported variables.
实现

Looks up a variable like __getitem__ or get but returns an Undefined object with the name of the name looked up.
Python frame 中的局域变量在函数中是不可变的，出于同样的原因，上下文是不可 变的

Implementation
当模板访问一个模板中没有定义的变量时， Jinja2 在上下文中查找变量，此后， 这个变量被视为其是在模板中定义得一样

Baseclass for all loaders.
Baseclass for all loaders. Subclass this and override get_source to implement a custom loading mechanism. The environment provides a get_template method that calls the loader’s load method to get the Template object.

A very basic example for a loader that looks up templates on the file system could look like this:
A very basic example for a loader that looks up templates on the file system could look like this:

Get the template source, filename and reload helper for a template.
Get the template source, filename and reload helper for a template. It’s passed the environment and template name and has to return a tuple in the form (source, filename, uptodate) or raise a TemplateNotFound error if it can’t locate the template.

The source part of the returned tuple must be the source of the template as unicode string or a ASCII bytestring.
The source part of the returned tuple must be the source of the template as unicode string or a ASCII bytestring. The filename should be the name of the file on the filesystem if it was loaded from there, otherwise None. The filename is used by python for the tracebacks if no loader extension is used.

The last item in the tuple is the uptodate function.
The last item in the tuple is the uptodate function. If auto reloading is enabled it’s always called to check if the template changed. No arguments are passed so the function must store the old state somewhere (for example in a closure). If it returns False the template will be reloaded.

Loads a template.
Loads a template. This method looks up the template in the cache or loads one by calling get_source(). Subclasses should not override this method as loaders working on collections of other loaders (such as PrefixLoader or ChoiceLoader) will not call this method but get_source directly.

Here a list of the builtin loaders Jinja2 provides:
这里有一个 Jinja2 提供的内置加载器的列表:

Loads templates from the file system.
Loads templates from the file system. This loader can find templates in folders on the file system and is the preferred way to load them.

The loader takes the path to the templates as string, or if multiple locations are wanted a list of them which is then looked up in the given order:
The loader takes the path to the templates as string, or if multiple locations are wanted a list of them which is then looked up in the given order:

Per default the template encoding is 'utf-8' which can be changed by setting the encoding parameter to something else.
Per default the template encoding is 'utf-8' which can be changed by setting the encoding parameter to something else.

To follow symbolic links, set the followlinks parameter to True:
Load templates from python eggs or packages. It is constructed with the name of the python package and the path to the templates in that package:

Changed in version 2.8+: The followlinks parameter was added.
If the package path is not given, 'templates' is assumed.

Load templates from python eggs or packages.
Per default the template encoding is 'utf-8' which can be changed by setting the encoding parameter to something else. Due to the nature of eggs it’s only possible to reload templates if the package was loaded from the file system and not a zip file.

If the package path is not given, 'templates' is assumed.
Loads a template from a python dict. It’s passed a dict of unicode strings bound to template names. This loader is useful for unittesting:

Per default the template encoding is 'utf-8' which can be changed by setting the encoding parameter to something else.
Because auto reloading is rarely useful this is disabled per default.

Loads a template from a python dict.
A loader that is passed a function which does the loading. The function becomes the name of the template passed and has to return either an unicode string with the template source, a tuple in the form (source, filename, uptodatefunc) or None if the template does not exist.

Because auto reloading is rarely useful this is disabled per default.
The uptodatefunc is a function that is called if autoreload is enabled and has to return True if the template is still up to date. For more details have a look at BaseLoader.get_source() which has the same return value.

A loader that is passed a function which does the loading.
A loader that is passed a dict of loaders where each loader is bound to a prefix. The prefix is delimited from the template by a slash per default, which can be changed by setting the delimiter argument to something else:

The uptodatefunc is a function that is called if autoreload is enabled and has to return True if the template is still up to date.
By loading 'app1/index.html' the file from the app1 package is loaded, by loading 'app2/index.html' the file from the second.

A loader that is passed a dict of loaders where each loader is bound to a prefix.
This loader works like the PrefixLoader just that no prefix is specified. If a template could not be found by one loader the next one is tried.

By loading 'app1/index.html' the file from the app1 package is loaded, by loading 'app2/index.html' the file from the second.
This is useful if you want to allow users to override builtin templates from a different location.

This loader works like the PrefixLoader just that no prefix is specified.
This loader loads templates from precompiled templates.

This is useful if you want to allow users to override builtin templates from a different location.
Example usage:

This loader loads templates from precompiled templates.
Templates can be precompiled with Environment.compile_templates().

This is especially useful if you have a web application that is initialized on the first request and Jinja compiles many templates at once which slows down the application.
这在当你有一个在首个应用初始化的 web 应用， Jinja 一次性编译大量模板拖慢应用时尤其 有用

To use a bytecode cache, instantiate it and pass it to the Environment.
要使用字节码缓存，把它实例化并传给 Environment 

To implement your own bytecode cache you have to subclass this class and override load_bytecode() and dump_bytecode().
To implement your own bytecode cache you have to subclass this class and override load_bytecode() and dump_bytecode(). Both of these methods are passed a Bucket.

A very basic bytecode cache that saves the bytecode on the file system:
A very basic bytecode cache that saves the bytecode on the file system:

A more advanced version of a filesystem based bytecode cache is part of Jinja2.
A more advanced version of a filesystem based bytecode cache is part of Jinja2.

Clears the cache.
Clears the cache. This method is not used by Jinja2 but should be implemented to allow applications to clear the bytecode cache used by a particular environment.

Subclasses have to override this method to write the bytecode from a bucket back to the cache.
Subclasses have to override this method to write the bytecode from a bucket back to the cache. If it unable to do so it must not fail silently but raise an exception.

Subclasses have to override this method to load bytecode into a bucket.
Subclasses have to override this method to load bytecode into a bucket. If they are not able to find code in the cache for the bucket, it must not do anything.

Buckets are used to store the bytecode for one template.
Buckets are used to store the bytecode for one template. It’s created and initialized by the bytecode cache and passed to the loading functions.

The buckets get an internal checksum from the cache assigned and use this to automatically reject outdated cache material.
The buckets get an internal checksum from the cache assigned and use this to automatically reject outdated cache material. Individual bytecode cache subclasses don’t have to care about cache invalidation.

The Environment that created the bucket.
创建 bucket 的 Environment

The unique cache key for this bucket
该 bucket 的唯一键

The bytecode if it’s loaded, otherwise None.
如果已加载，则为字节码，否则为 None 

Load bytecode from a string.
Load bytecode from a string.

Return the bytecode as string.
Return the bytecode as string.

Loads bytecode from a file or file like object.
Loads bytecode from a file or file like object.

Resets the bucket (unloads the bytecode).
Resets the bucket (unloads the bytecode).

Dump the bytecode into the file or file like object passed.
Dump the bytecode into the file or file like object passed.

Builtin bytecode caches:
内建的字节码缓存:

A bytecode cache that stores bytecode on the filesystem.
A bytecode cache that stores bytecode on the filesystem. It accepts two arguments: The directory where the cache items are stored and a pattern string that is used to build the filename.

If no directory is specified a default cache directory is selected.
If no directory is specified the system temporary items folder is used.

The pattern can be used to have multiple separate caches operate on the same directory.
The pattern can be used to have multiple separate caches operate on the same directory. The default pattern is '__jinja2_%s.cache'. %s is replaced with the cache key.

This bytecode cache supports clearing of the cache using the clear method.
This bytecode cache supports clearing of the cache using the clear method.

This class implements a bytecode cache that uses a memcache cache for storing the information.
This class implements a bytecode cache that uses a memcache cache for storing the information. It does not enforce a specific memcache library (tummy’s memcache or cmemcache) but will accept any class that provides the minimal interface required.

Libraries compatible with this class:
Libraries compatible with this class:

(Unfortunately the django cache interface is not compatible because it does not support storing binary data, only unicode.
(Unfortunately the django cache interface is not compatible because it does not support storing binary data, only unicode. You can however pass the underlying cache client to the bytecode cache which is available as django.core.cache.cache._client.)

The minimal interface for the client passed to the constructor is this:
The minimal interface for the client passed to the constructor is this:

Stores the bytecode in the cache.
Stores the bytecode in the cache. value is a string and timeout the timeout of the key. If timeout is not provided a default timeout or no timeout should be assumed, if it’s provided it’s an integer with the number of seconds the cache item should exist.

Returns the value for the cache key.
Returns the value for the cache key. If the item does not exist in the cache the return value must be None.

The other arguments to the constructor are the prefix for all keys that is added before the actual cache key and the timeout for the bytecode in the cache system.
The other arguments to the constructor are the prefix for all keys that is added before the actual cache key and the timeout for the bytecode in the cache system. We recommend a high (or no) timeout.

This bytecode cache does not support clearing of used items in the cache.
This bytecode cache does not support clearing of used items in the cache. The clear method is a no-operation function.

New in version 2.7: Added support for ignoring memcache errors through the ignore_memcache_errors parameter.
New in version 2.7: Added support for ignoring memcache errors through the ignore_memcache_errors parameter.

Utilities¶
实用工具¶

These helper functions and classes are useful if you add custom filters or functions to a Jinja2 environment.
这些辅助函数和类在你向 Jinja2 环境中添加自定义过滤器或函数时很有用

Decorator for marking environment dependent filters.
Decorator for marking evironment dependent filters. The current Environment is passed to the filter as first argument.

Decorator for marking context dependent filters.
Decorator for marking context dependent filters. The current Context will be passed as first argument.

Decorator for marking eval-context dependent filters.
Decorator for marking eval-context dependent filters. An eval context object is passed as first argument. For more information about the eval context, see 求值上下文.

New in version 2.4.
New in version 2.4.

This decorator can be used to mark a function or method as environment callable.
This decorator can be used to mark a function or method as environment callable. This decorator works exactly like the contextfunction() decorator just that the first argument is the active Environment and not context.

This decorator can be used to mark a function or method context callable.
This decorator can be used to mark a function or method context callable. A context callable is passed the active Context as first argument when called from the template. This is useful if a function wants to get access to the context or functions provided on the context object. For example a function that returns a sorted list of template variables the current template exports could look like this:

This decorator can be used to mark a function or method as an eval context callable.
This decorator can be used to mark a function or method as an eval context callable. This is similar to the contextfunction() but instead of passing the context, an evaluation context object is passed. For more information about the eval context, see 求值上下文.

New in version 2.4.
New in version 2.4.

Convert the characters &, <, >, ', and " in string s to HTML-safe sequences.
把字符串 s 中 & 、 < 、 > 、 ' 和 " 转换为 HTML 安 全的序列

Use this if you need to display text that might contain such characters in HTML.
如果你需要在 HTML 中显示可能包含这些字符的文本，可以使用它

This function will not escaped objects that do have an HTML representation such as already escaped data.
这 个函数不会转义对象

The return value is a Markup string.
返回值是一个 Markup 字符串

Jinja2 keeps internal caches for environments and lexers.
Jinja2 keeps internal caches for environments and lexers. These are used so that Jinja2 doesn’t have to recreate environments and lexers all the time. Normally you don’t have to care about that but if you are messuring memory consumption you may want to clean the caches.

Check if the object passed is undefined.
Check if the object passed is undefined. This does nothing more than performing an instance check against Undefined but looks nicer. This can be used for custom filters or tests that want to react to undefined variables. For example a custom default filter can look like this:

Marks a string as being safe for inclusion in HTML/XML output without needing to be escaped.
Marks a string as being safe for inclusion in HTML/XML output without needing to be escaped. This implements the __html__ interface a couple of frameworks and web applications use. Markup is a direct subclass of unicode and provides all the methods of unicode just that it escapes arguments passed and always returns Markup.

The escape function returns markup objects so that double escaping can’t happen.
The escape function returns markup objects so that double escaping can’t happen.

The constructor of the Markup class can be used for three different things: When passed an unicode object it’s assumed to be safe, when passed an object with an HTML representation (has an __html__ method) that representation is used, otherwise the object passed is converted into a unicode string and then assumed to be safe:
The constructor of the Markup class can be used for three different things: When passed an unicode object it’s assumed to be safe, when passed an object with an HTML representation (has an __html__ method) that representation is used, otherwise the object passed is converted into a unicode string and then assumed to be safe:

If you want object passed being always treated as unsafe you can use the escape() classmethod to create a Markup object:
If you want object passed being always treated as unsafe you can use the escape() classmethod to create a Markup object:

Operations on a markup string are markup aware which means that all arguments are passed through the escape() function:
Operations on a markup string are markup aware which means that all arguments are passed through the escape() function:

Escape the string.
Escape the string. Works like escape() with the difference that for subclasses of Markup this function would return the correct subclass.

Unescape markup into an text_type string and strip all tags.
Unescape markup into an text_type string and strip all tags. This also resolves known HTML4 and XHTML entities. Whitespace is normalized to one:

Unescape markup again into an text_type string.
Unescape markup again into an text_type string. This also resolves known HTML4 and XHTML entities:

Note
Note

The Jinja2 Markup class is compatible with at least Pylons and Genshi.
Jinja2 的 Markup 类至少与 Pylons 和 Genshi 兼容

It’s expected that more template engines and framework will pick up the __html__ concept soon.
预计不久更多模板 引擎和框架会采用 __html__ 的概念

Exceptions¶
异常¶

Baseclass for all template errors.
Baseclass for all template errors.

Raised if a template tries to operate on Undefined.
Raised if a template tries to operate on Undefined.

Raised if a template does not exist.
Raised if a template does not exist.

Like TemplateNotFound but raised if multiple templates are selected.
Like TemplateNotFound but raised if multiple templates are selected. This is a subclass of TemplateNotFound exception, so just catching the base exception will catch both.

New in version 2.2.
New in version 2.2.

Raised to tell the user that there is a problem with the template.
Raised to tell the user that there is a problem with the template.

The error message as utf-8 bytestring.
错误信息的 utf-8 字节串

The line number where the error occurred
发生错误的行号

The load name for the template as unicode string.
模板的加载名的 unicode 字符串

The filename that loaded the template as bytestring in the encoding of the file system (most likely utf-8 or mbcs on Windows systems).
加载的模板的文件名字节串，以文件系统的编码（多是 utf-8 ， Windows 是 mbcs ）

The reason why the filename and error message are bytestrings and not unicode strings is that Python 2.x is not using unicode for exceptions and tracebacks as well as the compiler.
文件名和错误消息是字节串而不是 unicode 字符串的原因是，在 Python 2.x 中，不对异常和回溯使用 unicode ，编译器同样

This will change with Python 3.
这会在 Python 3 改变

Like a template syntax error, but covers cases where something in the template caused an error at compile time that wasn’t necessarily caused by a syntax error.
Like a template syntax error, but covers cases where something in the template caused an error at compile time that wasn’t necessarily caused by a syntax error. However it’s a direct subclass of TemplateSyntaxError and has the same attributes.

Custom Filters¶
自定义过滤器¶

Custom filters are just regular Python functions that take the left side of the filter as first argument and the arguments passed to the filter as extra arguments or keyword arguments.
自定义过滤器只是常规的 Python 函数，过滤器左边作为第一个参数，其余的参数作 为额外的参数或关键字参数传递到过滤器

For example in the filter {{ 42|myfilter(23) }} the function would be called with myfilter(42, 23).
例如在过滤器 {{ 42|myfilter(23) }} 中，函数被以 myfilter(42, 23) 调 用

Here for example a simple filter that can be applied to datetime objects to format them:
这里给出一个简单的过滤器示例，可以应用到 datetime 对象来格式化它们:

You can register it on the template environment by updating the filters dict on the environment:
你可以更新环境上的 filters 字典来把它注册到模板环境上:

Inside the template it can then be used as follows:
在模板中使用如下:

Filters can also be passed the current template context or environment.
也可以传给过滤器当前模板上下文或环境

This is useful if a filter wants to return an undefined value or check the current autoescape setting.
当过滤器要返回一个未定义值或检查当前的 autoescape 设置时很有用

For this purpose three decorators exist: environmentfilter(), contextfilter() and evalcontextfilter().
为此，有三个装饰器： environmentfilter() 、 contextfilter() 和 evalcontextfilter() 

Here a small example filter that breaks a text into HTML line breaks and paragraphs and marks the return value as safe HTML string if autoescaping is enabled:
这里是一个小例子，过滤器把一个文本在 HTML 中换行或分段，并标记返回值为安全 的 HTML 字符串，因为自动转义是启用的:

Context filters work the same just that the first argument is the current active Context rather then the environment.
上下文过滤器工作方式相同，只是第一个参数是当前活动的 Context 而 不是环境

Evaluation Context¶
求值上下文¶

The evaluation context (short eval context or eval ctx) is a new object introduced in Jinja 2.4 that makes it possible to activate and deactivate compiled features at runtime.
求值上下文（缩写为 eval context 或 eval ctx ）是 Jinja 2.4 中引入的新对象， 并可以在运行时激活/停用已编译的特性

Currently it is only used to enable and disable the automatic escaping but can be used for extensions as well.
当前它只用于启用和禁用自动转义，但也可以用于扩展

In previous Jinja versions filters and functions were marked as environment callables in order to check for the autoescape status from the environment.
在之前的 Jinja 版本中，过滤器和函数被标记为环境可调用的来从环境中检查自动 转义的状态

In new versions it’s encouraged to check the setting from the evaluation context instead.
在新版本中鼓励通过求值上下文来检查这个设定

Previous versions:
之前的版本:

In new versions you can either use a contextfilter() and access the evaluation context from the actual context, or use a evalcontextfilter() which directly passes the evaluation context to the function:
在新版本中，你可以用 contextfilter() 从实际的上下文中访问求值上下 文，或用 evalcontextfilter() 直接把求值上下文传递给函数:

The evaluation context must not be modified at runtime.
求值上下文一定不能在运行时修改

Modifications must only happen with a nodes.EvalContextModifier and nodes.ScopedEvalContextModifier from an extension, not on the eval context object itself.
修改只能在扩展中的 用 nodes.EvalContextModifier 和 nodes.ScopedEvalContextModifier 发生，而不是通过求值上下文对 象本身

Holds evaluation time information.
Holds evaluation time information. Custom attributes can be attached to it in extensions.

True or False depending on if autoescaping is active or not.
True 或 False 取决于自动转义是否激活

True if the compiler cannot evaluate some expressions at compile time.
如果编译器不能在编译期求出某些表达式的值，为 True 

At runtime this should always be False.
在运行时应该 始终为 False 

Custom Tests¶
自定义测试¶

Tests work like filters just that there is no way for a test to get access to the environment or context and that they can’t be chained.
测试像过滤器一样工作，只是测试不能访问环境或上下文，并且它们不能链式使用

The return value of a test should be True or False.
 测试的返回值应该是 True 或 False 

The purpose of a test is to give the template designers the possibility to perform type and conformability checks.
测试的用途是让模板设计者运行类型和 一致性检查

Here a simple test that checks if a variable is a prime number:
这里是一个简单的测试，检验一个变量是否是素数:

You can register it on the template environment by updating the tests dict on the environment:
你可以通过更新环境上的 tests 字典来注册它:

A template designer can then use the test like this:
模板设计者可以在之后这样使用测试:

The Global Namespace¶
全局命名空间¶

Variables stored in the Environment.globals dict are special as they are available for imported templates too, even if they are imported without context.
Environment.globals 字典中的变量是特殊的，它们对导入的模板也是可用的， 即使它们不通过上下文导入

This is the place where you can put variables and functions that should be available all the time.
这是你可以放置始终可访问的变量和函数的地方

Additionally Template.globals exist that are variables available to a specific template that are available to all render() calls.
此外， Template.globals 是那些对特定模板可用的变量，即对所有的 render() 调用可用

Low Level API¶
低层 API¶

The low level API exposes functionality that can be useful to understand some implementation details, debugging purposes or advanced extension techniques.
低层 API 暴露的功能对理解一些实现细节、调试目的或高级 扩展 技巧是有用的

Unless you know exactly what you are doing we don’t recommend using any of those.
除非你准确地了解你在做什么，否则 不推荐使用这些 API 

Lex the given sourcecode and return a generator that yields tokens as tuples in the form (lineno, token_type, value).
Lex the given sourcecode and return a generator that yields tokens as tuples in the form (lineno, token_type, value). This can be useful for extension development and debugging templates.

This does not perform preprocessing.
This does not perform preprocessing. If you want the preprocessing of the extensions to be applied you have to filter source through the preprocess() method.

Parse the sourcecode and return the abstract syntax tree.
Parse the sourcecode and return the abstract syntax tree. This tree of nodes is used by the compiler to convert the template into executable source- or bytecode. This is useful for debugging or to extract information from templates.

If you are developing Jinja2 extensions this gives you a good overview of the node tree generated.
If you are developing Jinja2 extensions this gives you a good overview of the node tree generated.

Preprocesses the source with all extensions.
Preprocesses the source with all extensions. This is automatically called for all parsing and compiling methods but not for lex() because there you usually only want the actual source tokenized.

Create a new Context for this template.
Create a new Context for this template. The vars provided will be passed to the template. Per default the globals are added to the context. If shared is set to True the data is passed as it to the context without adding the globals.

locals can be a dict of local variables for internal usage.
locals can be a dict of local variables for internal usage.

This is the low level render function.
这是低层的渲染函数

It’s passed a Context that has to be created by new_context() of the same template or a compatible template.
它接受一个必须由相同模板或兼容的模板的 new_context() 创建的 Context 

This render function is generated by the compiler from the template code and returns a generator that yields unicode strings.
这个渲染函数由编译器从 模板代码产生，并返回一个生产 unicode 字符串的生成器

If an exception in the template code happens the template engine will not rewrite the exception but pass through the original one.
如果模板代码中发生了异常，模板引擎不会重写异常而是直接传递原始的异常

As a matter of fact this function should only be called from within a render() / generate() / stream() call.
 事实上，这个函数只在 render() / generate() / stream() 的调用里被调用

A dict of block render functions.
一个块渲染函数的字典

Each of these functions works exactly like the root_render_func() with the same limitations.
其中的每个函数与 root_render_func() 的工作 相同，并且有相同的限制

This attribute is False if there is a newer version of the template available, otherwise True.
如果有可用的新版本模板，这个属性是 False ，否则是 True 

Note
注意

The low-level API is fragile.
低层 API 是易碎的

Future Jinja2 versions will try not to change it in a backwards incompatible way but modifications in the Jinja2 core may shine through.
未来的 Jinja2 的版本将不会试图以不向后兼容的方式修改它， 而是在 Jinja2 核心的修改中表现出来

For example if Jinja2 introduces a new AST node in later versions that may be returned by parse().
比如如果 Jinja2 在之后的版本中引入一 个新的 AST 节点，它会由 parse() 返回

The Meta API¶
元 API¶

New in version 2.2.
New in version 2.2.

