Chapter 10: Advanced Models¶
第十章：模型高级进阶

In Chapter 5, we presented an introduction to Django’s database layer – how to define models and how to use the database API to create, retrieve, update and delete records.
在第5章里，我们介绍了Django的数据层如何定义数据模型以及如何使用数据库API来创建、检索、更新以及删除记录 在这章里，我们将向你介绍Django在这方面的一些更高级功能

Related Objects¶
相关对象

Recall our book models from Chapter 5:
先让我们回忆一下在第五章里的关于书本(book)的数据模型：

As we explained in Chapter 5, accessing the value for a particular field on a database object is as straightforward as using an attribute.
如我们在第5章的讲解,获取数据库对象的特定字段的值只需直接使用属性

For example, to determine the title of the book with ID 50, we’d do the following:
 例如,要确定ID为50的书本的标题,我们这样做:

But one thing we didn’t mention previously is that related objects – fields expressed as either a ForeignKey or ManyToManyField – act slightly differently.
但是,在之前有一件我们没提及到的是表现为ForeignKey 或 ManyToManyField的关联对象字段,它们的作用稍有不同

When you access a field that’s a ForeignKey, you’ll get the related model object.
当你获取一个ForeignKey 字段时,你会得到相关的数据模型对象

For example:
 例如:

With ForeignKey fields, it works the other way, too, but it’s slightly different due to the non-symmetrical nature of the relationship.
对于用ForeignKey 来定义的关系来说，在关系的另一端也能反向的追溯回来，只不过由于不对称性的关系而稍有不同

To get a list of books for a given publisher, use publisher.book_set.all(), like this:
 通过一个publisher 对象，直接获取 books ，用 publisher.book_set.all() ，如下：

Behind the scenes, book_set is just a QuerySet (as covered in Chapter 5), and it can be filtered and sliced like any other QuerySet.
实际上，book_set 只是一个 QuerySet（参考第5章的介绍），所以它可以像QuerySet一样,能实现数据过滤和分切，例如：

The attribute name book_set is generated by prepending the lower case model name to _set.
属性名称book_set是由模型名称的小写(如book)加_set组成的

Many-to-many values work like foreign-key values, except we deal with QuerySet values instead of model instances.
多对多和外键工作方式相同，只不过我们处理的是QuerySet而不是模型实例

For example, here’s how to view the authors for a book:
 例如,这里是如何查看书籍的作者：

It works in reverse, too.
反向查询也可以

To view all of the books for an author, use author.book_set, like this:
 要查看一个作者的所有书籍,使用author.book_set ,就如这样:

Here, as with ForeignKey fields, the attribute name book_set is generated by prepending the lower case model name to _set.
这里,就像使用 ForeignKey字段一样，属性名book_set是在数据模型(model)名后追加_set

Making Changes to a Database Schema¶
更改数据库模式(Database Schema)

When we introduced the syncdb command in Chapter 5, we noted that syncdb merely creates tables that don’t yet exist in your database – it does not sync changes in models or perform deletions of models.
在我们在第5章介绍 syncdb 这个命令时, 我们注意到 syncdb仅仅创建数据库里还没有的表，它 并不 对你数据模型的修改进行同步,也不处理数据模型的删除

If you add or change a model’s field, or if you delete a model, you’ll need to make the change in your database manually.
 如果你新增或修改数据模型里的字段,或是删除了一个数据模型，你需要手动在数据库里进行相应的修改

This section explains how to do that.
 这段将解释了具体怎么做：

When dealing with schema changes, it’s important to keep a few things in mind about how Django’s database layer works:
当处理模型修改的时候，将Django的数据库层的工作流程铭记于心是很重要的

Making schema changes is a matter of changing the various pieces – the Python code and the database itself – in the right order.
如果模型包含一个未曾在数据库里建立的字段，Django会报出错信息

Django will complain loudly if a model contains a field that has not yet been created in the database table.
Django_不_关心数据库表中是否存在未在模型中定义的列

Django does not care if a database table contains columns that are not defined in the model.
Django_不_关心数据库中是否存在未被模型表示的表格

Django does not care if a database contains a table that is not represented by a model.
改变模型的模式架构意味着需要按照顺序更改Python代码和数据库

When adding a field to a table/model in a production setting, the trick is to take advantage of the fact that Django doesn’t care if a table contains columns that aren’t defined in the model.
当要向一个产品设置表(或者说是model)添加一个字段的时候，要使用的技巧是利用Django不关心表里是否包含model里所没有的列的特性

The strategy is to add the column in the database, and then update the Django model to include the new field.
 策略就是现在数据库里加入字段，然后同步Django的模型以包含新字段

However, there’s a bit of a chicken-and-egg problem here, because in order to know how the new database column should be expressed in SQL, you need to look at the output of Django’s manage.py sqlall command, which requires that the field exist in the model.
然而 这里有一个鸡生蛋蛋生鸡的问题 ,由于要想了解新增列的SQL语句，你需要使用Django的manage.py sqlall命令进行查看 ,而这又需要字段已经在模型里存在了

(Note that you’re not required to create your column with exactly the same SQL that Django would, but it’s a good idea to do so, just to be sure everything’s in sync.)
 (注意:你并 _不是非得使用_与Django相同的SQL语句创建新的字段，但是这样做确实是一个好主意 ,它能让一切都保持同步

The solution to the chicken-and-egg problem is to use a development environment instead of making the changes on a production server.
这个鸡-蛋的问题的解决方法是在开发者环境里而不是发布环境里实现这个变化

(You are using a testing/development environment, right?) Here are the detailed steps to take.
 (你_正_使用的是测试/开发环境，对吧

First, take these steps in the development environment (i.e., not on the production server):
首先，进入开发环境(也就是说，不是在发布环境里)：

Add the field to your model.
在你的模型里添加字段

Run manage.py sqlall [yourapp] to see the new CREATE TABLE statement for the model.
运行 manage.py sqlall [yourapp] 来测试模型新的 CREATE TABLE 语句

Note the column definition for the new field.
 注意为新字段的列定义

Start your database’s interactive shell (e.g., psql or mysql, or you can use manage.py dbshell).
开启你的数据库的交互命令界面(比如, psql 或mysql , 或者可以使用 manage.py dbshell )

Execute an ALTER TABLE statement that adds your new column.
 执行ALTER TABLE 语句来添加新列

Launch the Python interactive shell with manage.py shell and verify that the new field was added properly by importing the model and selecting from the table (e.g., MyModel.objects.all()[:5]).
使用Python的manage.py shell，通过导入模型和选中表单(例如， MyModel.objects.all()[:5] )来验证新的字段是否被正确的添加 ,如果一切顺利,所有的语句都不会报错

Then on the production server perform these steps:
然后在你的产品服务器上再实施一遍这些步骤

Start your database’s interactive shell.
启动数据库的交互界面

Execute the ALTER TABLE statement you used in step 3 of the development environment steps.
执行在开发环境步骤中，第三步的ALTER TABLE语句

Add the field to your model.
将新的字段加入到模型中

If you’re using source-code revision control and you checked in your change in development environment step 1, now is the time to update the code (e.g., svn update, with Subversion) on the production server.
 如果你使用了某种版本控制工具，并且在第一步中，已经提交了你在开发环境上的修改，现在，可以在生产环境中更新你的代码了（例如，如果你使用Subversion，执行svn update

Restart the Web server for the code changes to take effect.
重新启动Web server，使修改生效

For example, let’s walk through what we’d do if we added a num_pages field to the Book model from Chapter 5.
让我们实践下，比如添加一个num_pages字段到第五章中Book模型

First, we’d alter the model in our development environment to look like this:
首先，我们会把开发环境中的模型改成如下形式：

(Note: Read the section “Making Fields Optional” in Chapter 6, plus the sidebar “Adding NOT NULL Columns” below for important details on why we included blank=True and null=True.)
(注意 阅读第六章的“设置可选字段”以及本章下面的“添加非空列”小节以了解我们在这里添加blank=True和null=True的原因

Then we’d run the command manage.py sqlall books to see the CREATE TABLE statement.
然后，我们运行命令manage.py sqlall books 来查看CREATE TABLE语句

Depending on your database backend, it would look something like this:
 语句的具体内容取决与你所使用的数据库， 大概是这个样子：

The new column is represented like this:
新加的字段被这样表示：

Next, we’d start the database’s interactive shell for our development database by typing psql (for PostgreSQL), and we’d execute the following statements:
接下来，我们要在开发环境上运行数据库客户端，如果是PostgreSQL，运行 psql,，然后，我执行如下语句

Adding NOT NULL Columns
添加 非NULL 字段

There’s a subtlety here that deserves mention.
这里有个微妙之处值得一提

When we added the num_pages field to our model, we included the blank=True and null=True options.
 在我们添加字段num_pages的时候，我们使用了 blank=True 和 null=True 选项

We did this because a database column will contain NULL values when you first create it.
 这是因为在我们第一次创建它的时候，这个数据库字段会含有空值

However, it’s also possible to add columns that cannot contain NULL values.
然而，想要添加不能含有空值的字段也是可以的

To do this, you have to create the column as NULL, then populate the column’s values using some default(s), and then alter the column to set the NOT NULL modifier.
 要想实现这样的效果，你必须先创建 NULL 型的字段，然后将该字段的值填充为某个默认值，然后再将该字段改为 NOT NULL 型

For example:
 例如：

If you go down this path, remember that you should leave off blank=True and null=True in your model (obviously).
如果你这样做，记得你不要在模型中添加 blank=True 和 null=True 选项

After the ALTER TABLE statement, we’d verify that the change worked properly by starting the Python shell and running this code:
执行ALTER TABLE之后，我们要验证一下修改结果是否正确

If that code didn’t cause errors, we’d switch to our production server and execute the ALTER TABLE statement on the production database.
如果没有异常发生，我们将切换到生产服务器，然后在生产环境的数据库中执行命令ALTER TABLE 然后我们更新生产环境中的模型，最后重启web服务器

Removing a field from a model is a lot easier than adding one.
从Model中删除一个字段要比添加容易得多

To remove a field, just follow these steps:
 删除字段，仅仅只要以下几个步骤：

Remove the field from your model and restart the Web server.
删除字段，然后重新启动你的web服务器

Remove the column from your database, using a command like this:
用以下命令从数据库中删除字段：

Make sure to do it in this order.
请保证操作的顺序正确

If you remove the column from your database first, Django will immediately begin raising errors.
 如果你先从数据库中删除字段，Django将会立即抛出异常

Because many-to-many fields are different than normal fields, the removal process is different:
由于多对多关联字段不同于普通字段，所以删除操作是不同的

Remove the ManyToManyField from your model and restart the Web server.
从你的模型中删除ManyToManyField，然后重启web服务器

Remove the many-to-many table from your database, using a command like this:
用下面的命令从数据库删除关联表：

As in the previous section, make sure to do it in this order.
像上面一样，注意操作的顺序

Removing a model entirely is as easy as removing a field.
删除整个模型要比删除一个字段容易

To remove a model, just follow these steps:
 删除一个模型只要以下几个步骤：

Remove the model from your models.py file and restart the Web server.
从文件中删除你想要删除的模型，然后重启web 服务器models.py

Remove the table from your database, using a command like this:
然后用以下命令从数据库中删除表：

Note that you might need to remove any dependent tables from your database first – e.g., any tables that have foreign keys to books_book.
当你需要从数据库中删除任何有依赖的表时要注意（也就是任何与表books_book有外键的表 ）

As in the previous sections, make sure to do it in this order.
正如在前面部分，一定要按这样的顺序做

Managers¶
Managers

In the statement Book.objects.all(), objects is a special attribute through which you query your database.
在语句Book.objects.all()中，objects是一个特殊的属性，需要通过它查询数据库

In Chapter 5, we briefly identified this as the model’s manager.
 在第5章，我们只是简要地说这是模块的manager 

Now it’s time to dive a bit deeper into what managers are and how you can use them.
现在是时候深入了解managers是什么和如何使用了

In short, a model’s manager is an object through which Django models perform database queries.
总之，模块manager是一个对象，Django模块通过它进行数据库查询

Each Django model has at least one manager, and you can create custom managers in order to customize database access.
 每个Django模块至少有一个manager，你可以创建自定义manager以定制数据库访问

There are two reasons you might want to create a custom manager: to add extra manager methods, and/or to modify the initial QuerySet the manager returns.
下面是你创建自定义manager的两个原因： 增加额外的manager方法，和/或修manager返回的初始QuerySet

Adding extra manager methods is the preferred way to add “table-level” functionality to your models.
增加额外的manager方法是为模块添加表级功能的首选办法

(For “row-level” functionality – i.e., functions that act on a single instance of a model object – use model methods, which are explained later in this chapter.)
 （至于行级功能，也就是只作用于模型对象实例的函数，一会儿将在本章后面解释

For example, let’s give our Book model a manager method title_count() that takes a keyword and returns the number of books that have a title containing that keyword.
例如,我们为Book模型定义了一个title_count()方法，它需要一个关键字，返回包含这个关键字的书的数量

(This example is slightly contrived, but it demonstrates how managers work.)
 （这个例子有点牵强，不过它可以说明managers如何工作

With this manager in place, we can now do this:
有了这个manager，我们现在可以这样做：

Here are some notes about the code:
下面是编码该注意的一些地方：

We’ve created a BookManager class that extends django.db.models.Manager.
我们建立了一个BookManager类，它继承了django.db.models.Manager

This has a single method, title_count(), which does the calculation.
这个类只有一个title_count()方法，用来做统计

Note that the method uses self.filter(), where self refers to the manager itself.
 注意，这个方法使用了self.filter()，此处self指manager本身

We’ve assigned BookManager() to the objects attribute on the model.
我们把BookManager()赋值给模型的objects属性

This has the effect of replacing the “default” manager for the model, which is called objects and is automatically created if you don’t specify a custom manager.
 它将取代模型的默认manager（objects）如果我们没有特别定义，它将会被自动创建

We call it objects rather than something else, so as to be consistent with automatically created managers.
 我们把它命名为objects，这是为了与自动创建的manager保持一致

Why would we want to add a method such as title_count()?
为什么我们要添加一个title_count()方法呢

To encapsulate commonly executed queries so that we don’t have to duplicate code.
是为了将经常使用的查询进行封装，这样我们就不必重复编码了

A manager’s base QuerySet returns all objects in the system.
manager的基本QuerySet返回系统中的所有对象

For example, Book.objects.all() returns all books in the book database.
 例如,Book.objects.all() 返回数据库book中的所有书本

You can override a manager’s base QuerySet by overriding the Manager.get_query_set() method.
我们可以通过覆盖Manager.get_query_set()方法来重写manager的基本QuerySet

get_query_set() should return a QuerySet with the properties you require.
 get_query_set()按照你的要求返回一个QuerySet

For example, the following model has two managers – one that returns all objects, and one that returns only the books by Roald Dahl.
例如,下面的模型有 两个 manager

With this sample model, Book.objects.all() will return all books in the database, but Book.dahl_objects.all() will only return the ones written by Roald Dahl.
在这个示例模型中,Book.objects.all()返回了数据库中的所有书本,而Book.dahl_objects.all()只返回了一本. 注意我们明确地将objects设置成manager的实例，因为如果我们不这么做，那么唯一可用的manager就将是dah1_objects

Of course, because get_query_set() returns a QuerySet object, you can use filter(), exclude() and all the other QuerySet methods on it.
当然,由于get_query_set()返回的是一个QuerySet对象，所以我们可以使用filter()，exclude()和其他一切QuerySet的方法

So these statements are all legal:
 像这些语法都是正确的：

This example also pointed out another interesting technique: using multiple managers on the same model.
这个例子也指出了其他有趣的技术： 在同一个模型中使用多个manager

You can attach as many Manager() instances to a model as you’d like.
 只要你愿意，你可以为你的模型添加多个manager()实例

This is an easy way to define common “filters” for your models.
 这是一个为模型添加通用滤器的简单方法

For example:
例如:

This example allows you to request Person.men.all(), Person.women.all(), and Person.people.all(), yielding predictable results.
这个例子允许你执行Person.men.all() ，Person.women.all() ，Person.people.all() 查询，生成你想要的结果

If you use custom Manager objects, take note that the first Manager Django encounters (in the order in which they’re defined in the model) has a special status.
如果你使用自定义的Manager对象，请注意，Django遇到的第一个Manager(以它在模型中被定义的位置为准)会有一个特殊状态

Django interprets this first Manager defined in a class as the “default” Manager, and several parts of Django (though not the admin application) will use that Manager exclusively for that model.
 Django将会把第一个Manager 定义为默认Manager ，Django的许多部分(但是不包括admin应用)将会明确地为模型使用这个manager

As a result, it’s often a good idea to be careful in your choice of default manager, in order to avoid a situation where overriding of get_query_set() results in an inability to retrieve objects you’d like to work with.
 结论是，你应该小心地选择你的默认manager

Model methods¶
模型方法

Define custom methods on a model to add custom “row-level” functionality to your objects.
为了给你的对像添加一个行级功能，那就定义一个自定义方法

Whereas managers are intended to do “table-wide” things, model methods should act on a particular model instance.
 有鉴于manager经常被用来用一些整表操作（table-wide），模型方法应该只对特殊模型实例起作用

This is a valuable technique for keeping business logic in one place – the model.
这是一项在模型的一个地方集中业务逻辑的技术

An example is the easiest way to explain this.
最好用例子来解释一下

Here’s a model with a few custom methods:
 这个模型有一些自定义方法：

The last method in this example is a “property.” Read more about properties at http://www.python.org/download/releases/2.2/descrintro/#property
例子中的最后一个方法是一个property

And here’s example usage:
这是用法的实例：

Executing Raw SQL Queries¶
执行原始SQL查询

Sometimes you’ll find that the Django database API can only take you so far, and you’ll want to write custom SQL queries against your database.
有时候你会发现Django数据库API带给你的也只有这么多，那你可以为你的数据库写一些自定义SQL查询

You can do this very easily by accessing the object django.db.connection, which represents the current database connection.
 你可以通过导入django.db.connection对像来轻松实现，它代表当前数据库连接

To use it, call connection.cursor() to get a cursor object.
 要使用它，需要通过connection.cursor()得到一个游标对像

Then, call cursor.execute(sql, [params]) to execute the SQL and cursor.fetchone() or cursor.fetchall() to return the resulting rows.
 然后，使用cursor.execute(sql, [params])来执行SQL语句，使用cursor.fetchone()或者cursor.fetchall()来返回记录集

For example:
 例如:

connection and cursor mostly implement the standard Python “DB-API,” which you can read about at http://www.python.org/peps/pep-0249.html.
connection和cursor几乎实现了标准Python DB-API，你可以访问 http://www.python.org/peps/pep-0249.html http://www.python.org/peps/pep-0249.html>__来获取更多信息

If you’re not familiar with the Python DB-API, note that the SQL statement in cursor.execute() uses placeholders, "%s", rather than adding parameters directly within the SQL.
 如果你对Python DB-API不熟悉，请注意在cursor.execute() 的SQL语句中使用“%s” ，而不要在SQL内直接添加参数

If you use this technique, the underlying database library will automatically add quotes and escaping to your parameter(s) as necessary.
 如果你使用这项技术，数据库基础库将会自动添加引号，同时在必要的情况下转意你的参数

Rather than littering your view code with these django.db.connection statements, it’s a good idea to put them in custom model methods or manager methods.
不要把你的视图代码和django.db.connection语句混杂在一起，把它们放在自定义模型或者自定义manager方法中是个不错的主意

For example, the above example could be integrated into a custom manager method like this:
 比如，上面的例子可以被整合成一个自定义manager方法，就像这样：

And sample usage:
然后这样使用:

What’s Next?¶
接下来做什么

In the next chapter, we’ll show you Django’s “generic views” framework, which lets you save time in building Web sites that follow common patterns.
在下一章 我们将讲解Django的通用视图框架，使用它创建常见的网站可以节省时间

© Copyright 2012, Matt Behrens.
www.shoucewang.com. All Rights Reserved. 手册网 版权所有

